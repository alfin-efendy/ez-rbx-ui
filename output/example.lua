-- Bundled Lua Script
-- Generated by Lua Bundler
-- https://github.com/alfin-efendy/lua-bundler

local EmbeddedModules = {}

-- Module: ../output/bundle.lua
EmbeddedModules["../output/bundle.lua"] = function()
    -- Bundled Lua Script
    -- Generated by Lua Bundler
    -- https://github.com/alfin-efendy/lua-bundler

    local EmbeddedModules = {}

    -- Module: components/numberbox
    EmbeddedModules["components/numberbox"] = function()
        --[[
        	NumberBox Component
        	EzUI Library - Modular Component

        	Creates a numeric input field with increment/decrement buttons
        ]]
        local NumberBox = {}

        local Colors

        function NumberBox:Init(_colors)
        	Colors = _colors
        end

        function NumberBox:Create(config)
        	local placeholder = config.Placeholder or "Enter number..."
        	local defaultValue = config.Default or 0
        	local callback = config.Callback or function() end
        	local minValue = config.Min or -math.huge
        	local maxValue = config.Max or math.huge
        	local increment = config.Increment or 1
        	local decimals = config.Decimals or 0
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local EzUIConfig = config.EzUIConfig

        	-- NumberBox state
        	local currentValue = defaultValue

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if EzUIConfig and type(EzUIConfig.GetValue) == "function" then
        			flagValue = EzUIConfig.GetValue(flag)
        		-- Fallback to EzUI.Flags
        		elseif EzUI and EzUI.Flags then
        			flagValue = EzUI.Flags[flag]
        		end

        		if flagValue ~= nil then
        			currentValue = flagValue
        			defaultValue = currentValue
        		end
        	end

        	-- Main numberbox container
        	local numberBoxContainer = Instance.new("Frame")
        	if isForAccordion then
        		numberBoxContainer.Size = UDim2.new(1, -10, 0, 25)
        		numberBoxContainer.Position = UDim2.new(0, 5, 0, currentY)
        		numberBoxContainer.ZIndex = 6
        	else
        		numberBoxContainer.Size = UDim2.new(1, -20, 0, 30)
        		numberBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
        		numberBoxContainer.ZIndex = 3
        		numberBoxContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	numberBoxContainer.BackgroundTransparency = 1
        	numberBoxContainer.Parent = parentContainer

        	-- Number input box
        	local numberBox = Instance.new("TextBox")
        	if isForAccordion then
        		numberBox.Size = UDim2.new(1, -45, 1, 0)
        		numberBox.TextSize = 12
        		numberBox.ZIndex = 7
        	else
        		numberBox.Size = UDim2.new(1, -60, 1, 0)
        		numberBox.TextSize = 14
        		numberBox.ZIndex = 4
        	end
        	numberBox.Position = UDim2.new(0, 0, 0, 0)
        	numberBox.BackgroundColor3 = Colors.Input.Background
        	numberBox.BorderColor3 = Colors.Input.Border
        	numberBox.BorderSizePixel = 1
        	numberBox.Text = decimals > 0 and string.format("%." .. decimals .. "f", defaultValue) or tostring(defaultValue)
        	numberBox.PlaceholderText = placeholder
        	numberBox.TextColor3 = Colors.Input.Text
        	numberBox.PlaceholderColor3 = Colors.Input.Placeholder
        	numberBox.Font = Enum.Font.SourceSans
        	numberBox.TextXAlignment = Enum.TextXAlignment.Center
        	numberBox.TextYAlignment = Enum.TextYAlignment.Center
        	numberBox.ClearTextOnFocus = false
        	numberBox.Parent = numberBoxContainer

        	-- Round corners for number box
        	local numberCorner = Instance.new("UICorner")
        	numberCorner.CornerRadius = UDim.new(0, 4)
        	numberCorner.Parent = numberBox

        	-- Increment button (up arrow)
        	local incrementBtn = Instance.new("TextButton")
        	if isForAccordion then
        		incrementBtn.Size = UDim2.new(0, 20, 0, 12)
        		incrementBtn.Position = UDim2.new(1, -22, 0, 1)
        		incrementBtn.TextSize = 8
        		incrementBtn.ZIndex = 7
        	else
        		incrementBtn.Size = UDim2.new(0, 25, 0, 14)
        		incrementBtn.Position = UDim2.new(1, -30, 0, 1)
        		incrementBtn.TextSize = 10
        		incrementBtn.ZIndex = 4
        	end
        	incrementBtn.BackgroundColor3 = Colors.Surface.Default
        	incrementBtn.BorderColor3 = Colors.Border.Default
        	incrementBtn.BorderSizePixel = 1
        	incrementBtn.Text = "▲"
        	incrementBtn.TextColor3 = Colors.Text.Secondary
        	incrementBtn.Font = Enum.Font.SourceSans
        	incrementBtn.Parent = numberBoxContainer

        	-- Decrement button (down arrow)
        	local decrementBtn = Instance.new("TextButton")
        	if isForAccordion then
        		decrementBtn.Size = UDim2.new(0, 20, 0, 12)
        		decrementBtn.Position = UDim2.new(1, -22, 0, 13)
        		decrementBtn.TextSize = 8
        		decrementBtn.ZIndex = 7
        	else
        		decrementBtn.Size = UDim2.new(0, 25, 0, 14)
        		decrementBtn.Position = UDim2.new(1, -30, 0, 15)
        		decrementBtn.TextSize = 10
        		decrementBtn.ZIndex = 4
        	end
        	decrementBtn.BackgroundColor3 = Colors.Surface.Default
        	decrementBtn.BorderColor3 = Colors.Border.Default
        	decrementBtn.BorderSizePixel = 1
        	decrementBtn.Text = "▼"
        	decrementBtn.TextColor3 = Colors.Text.Secondary
        	decrementBtn.Font = Enum.Font.SourceSans
        	decrementBtn.Parent = numberBoxContainer

        	-- Function to validate and update value
        	local function updateValue(newValue)
        		-- Clamp to min/max
        		newValue = math.max(minValue, math.min(maxValue, newValue))

        		-- Round to decimal places
        		if decimals > 0 then
        			local multiplier = 10 ^ decimals
        			newValue = math.floor(newValue * multiplier + 0.5) / multiplier
        		else
        			newValue = math.floor(newValue + 0.5)
        		end

        		currentValue = newValue


        	-- Update text box display
        	if decimals > 0 then
        		numberBox.Text = string.format("%." .. decimals .. "f", newValue)
        	else
        		numberBox.Text = tostring(newValue)
        	end

        	-- Save to configuration
        	if flag then
        		-- Check if using custom config object
        		if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
        			EzUIConfig.SetValue(flag, currentValue)
        		-- Fallback to EzUI.Flags
        		elseif EzUI and EzUI.Flags then
        			EzUI.Flags[flag] = currentValue
        			-- Auto-save if enabled
        			if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
        				saveConfiguration(EzUI.Configuration.FileName)
        			end
        		end
        	end		-- Call user callback
        		local success, errorMsg = pcall(function()
        			callback(currentValue)
        		end)

        		if not success then
        			warn("NumberBox callback error:", errorMsg)
        		end

        		return newValue
        	end

        	-- Text change handler with validation
        	numberBox.FocusLost:Connect(function()
        		local inputText = numberBox.Text
        		local numValue = tonumber(inputText)

        		if numValue then
        			updateValue(numValue)
        		else
        			-- Invalid input, revert to current value
        			if decimals > 0 then
        				numberBox.Text = string.format("%." .. decimals .. "f", currentValue)
        			else
        				numberBox.Text = tostring(currentValue)
        			end
        		end
        	end)

        	-- Increment button handler
        	incrementBtn.MouseButton1Click:Connect(function()
        		updateValue(currentValue + increment)
        	end)

        	-- Decrement button handler
        	decrementBtn.MouseButton1Click:Connect(function()
        		updateValue(currentValue - increment)
        	end)

        	-- Button hover effects
        	incrementBtn.MouseEnter:Connect(function()
        		incrementBtn.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	incrementBtn.MouseLeave:Connect(function()
        		incrementBtn.BackgroundColor3 = Colors.Surface.Default
        	end)

        	decrementBtn.MouseEnter:Connect(function()
        		decrementBtn.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	decrementBtn.MouseLeave:Connect(function()
        		decrementBtn.BackgroundColor3 = Colors.Surface.Default
        	end)

        	-- Focus effects
        	numberBox.Focused:Connect(function()
        		numberBox.BorderColor3 = Colors.Input.BorderFocus
        	end)

        	numberBox.FocusLost:Connect(function()
        		numberBox.BorderColor3 = Colors.Input.Border
        	end)

        	-- Return NumberBox API
        	local numberBoxAPI = {
        		GetValue = function()
        			return currentValue
        		end,
        		SetValue = function(newValue)
        			local numValue = tonumber(newValue)
        			if numValue then
        				updateValue(numValue)
        			else
        				warn("NumberBox SetValue: Expected number, got " .. type(newValue))
        			end
        		end,
        		SetMin = function(newMin)
        			minValue = tonumber(newMin) or -math.huge
        			updateValue(currentValue)
        		end,
        		SetMax = function(newMax)
        			maxValue = tonumber(newMax) or math.huge
        			updateValue(currentValue)
        		end,
        		SetIncrement = function(newIncrement)
        			increment = tonumber(newIncrement) or 1
        		end,
        		Clear = function()
        			updateValue(0)
        		end,
        		Focus = function()
        			numberBox:CaptureFocus()
        		end,
        		Blur = function()
        			numberBox:ReleaseFocus()
        		end,
        		SetCallback = function(newCallback)
        			callback = newCallback or function() end
        		end,
        		Set = function(newValue)
        			local numValue = tonumber(newValue)
        			if numValue then
        				updateValue(numValue)
        			end
        		end
        	}

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, numberBoxAPI)
        	end

        	return numberBoxAPI
        end

        return NumberBox

    end

    -- Module: components/separator
    EmbeddedModules["components/separator"] = function()
        --[[
        	Separator Component
        	EzUI Library - Modular Component

        	Creates a horizontal line separator
        ]]
        local Separator = {}

        local Colors

        function Separator:Init(_colors)
        	Colors = _colors
        end

        function Separator:Create(config)
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false

        	local separator = Instance.new("Frame")
        	if isForAccordion then
        		separator.Size = UDim2.new(1, 0, 0, 1)
        		separator.Position = UDim2.new(0, 0, 0, currentY + 5)
        		separator.ZIndex = 5
        	else
        		separator.Size = UDim2.new(1, -20, 0, 1)
        		separator.Position = UDim2.new(0, 10, 0, currentY + 5)
        		separator.ZIndex = 3
        		separator:SetAttribute("ComponentStartY", currentY)
        	end
        	separator.BackgroundColor3 = Colors.Special.Divider
        	separator.BorderSizePixel = 0
        	separator.Parent = parentContainer

        	-- Create Separator API
        	local separatorAPI = {}

        	separatorAPI.SetColor = function(color)
        		separator.BackgroundColor3 = color
        	end

        	return separatorAPI
        end

        return Separator

    end

    -- Module: components/toggle
    EmbeddedModules["components/toggle"] = function()
        --[[
        	Toggle Component
        	EzUI Library - Modular Component

        	Creates a toggle/switch with on/off states
        ]]
        local Toggle = {}

        local Colors

        function Toggle:Init(_colors)
        	Colors = _colors
        end

        function Toggle:Create(config)
        	local text = config.Name or config.Text or "Toggle"
        	local defaultValue = config.Default or false
        	local callback = config.Callback or function() end
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local EzUIConfig = config.EzUIConfig

        	-- Toggle state
        	local isToggled = defaultValue

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if EzUIConfig and type(EzUIConfig.GetValue) == "function" then
        			flagValue = EzUIConfig.GetValue(flag)
        		-- Fallback to EzUI.Flags
        		elseif EzUI and EzUI.Flags then
        			flagValue = EzUI.Flags[flag]
        		end

        		if flagValue ~= nil then
        			isToggled = flagValue
        		end
        	end

        	-- Main toggle container
        	local toggleContainer = Instance.new("Frame")
        	if isForAccordion then
        		toggleContainer.Size = UDim2.new(1, -10, 0, 25)
        		toggleContainer.Position = UDim2.new(0, 5, 0, currentY)
        		toggleContainer.ZIndex = 6
        	else
        		toggleContainer.Size = UDim2.new(1, -20, 0, 30)
        		toggleContainer.Position = UDim2.new(0, 10, 0, currentY)
        		toggleContainer.ZIndex = 3
        		toggleContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	toggleContainer.BackgroundTransparency = 1
        	toggleContainer.Parent = parentContainer

        	-- Toggle label
        	local toggleLabel = Instance.new("TextLabel")
        	if isForAccordion then
        		toggleLabel.Size = UDim2.new(1, -45, 1, 0)
        		toggleLabel.TextSize = 12
        		toggleLabel.ZIndex = 7
        	else
        		toggleLabel.Size = UDim2.new(1, -60, 1, 0)
        		toggleLabel.TextSize = 16
        		toggleLabel.ZIndex = 4
        	end
        	toggleLabel.Position = UDim2.new(0, 0, 0, 0)
        	toggleLabel.BackgroundTransparency = 1
        	toggleLabel.Text = text
        	toggleLabel.TextColor3 = Colors.Text.Primary
        	toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
        	toggleLabel.Font = Enum.Font.SourceSans
        	toggleLabel.Parent = toggleContainer

        	-- Toggle switch background
        	local toggleBg = Instance.new("Frame")
        	if isForAccordion then
        		toggleBg.Size = UDim2.new(0, 40, 0, 20)
        		toggleBg.Position = UDim2.new(1, -40, 0.5, -10)
        		toggleBg.ZIndex = 7
        	else
        		toggleBg.Size = UDim2.new(0, 50, 0, 24)
        		toggleBg.Position = UDim2.new(1, -50, 0.5, -12)
        		toggleBg.ZIndex = 4
        	end
        	toggleBg.BackgroundColor3 = isToggled and Colors.Toggle.On or Colors.Toggle.Off
        	toggleBg.BorderSizePixel = 0
        	toggleBg.Parent = toggleContainer

        	-- Round corners for toggle background
        	local toggleBgCorner = Instance.new("UICorner")
        	toggleBgCorner.CornerRadius = UDim.new(0, isForAccordion and 10 or 12)
        	toggleBgCorner.Parent = toggleBg

        	-- Toggle switch button (circle)
        	local toggleButton = Instance.new("TextButton")
        	if isForAccordion then
        		toggleButton.Size = UDim2.new(0, 16, 0, 16)
        		toggleButton.Position = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
        		toggleButton.ZIndex = 8
        	else
        		toggleButton.Size = UDim2.new(0, 20, 0, 20)
        		toggleButton.Position = isToggled and UDim2.new(1, -22, 0.5, -10) or UDim2.new(0, 2, 0.5, -10)
        		toggleButton.ZIndex = 5
        	end
        	toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	toggleButton.BorderSizePixel = 0
        	toggleButton.Text = ""
        	toggleButton.Parent = toggleBg

        	-- Round corners for toggle button
        	local toggleButtonCorner = Instance.new("UICorner")
        	toggleButtonCorner.CornerRadius = UDim.new(0, isForAccordion and 8 or 10)
        	toggleButtonCorner.Parent = toggleButton

        	-- Function to update toggle appearance
        	local function updateToggleAppearance()
        		local targetBgColor = isToggled and Colors.Toggle.On or Colors.Toggle.Off
        		local targetPosition

        		if isForAccordion then
        			targetPosition = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
        		else
        			targetPosition = isToggled and UDim2.new(1, -22, 0.5, -10) or UDim2.new(0, 2, 0.5, -10)
        		end

        		-- Animate background color
        		local bgTween = game:GetService("TweenService"):Create(
        			toggleBg,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{BackgroundColor3 = targetBgColor}
        		)
        		bgTween:Play()

        		-- Animate button position
        		local buttonTween = game:GetService("TweenService"):Create(
        			toggleButton,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Position = targetPosition}
        		)
        		buttonTween:Play()
        	end

        	-- Toggle click handler
        	local function handleToggle()
        		isToggled = not isToggled
        		updateToggleAppearance()

        		-- Save to configuration
        		if flag then
        			-- Check if using custom config object
        			if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
        				EzUIConfig.SetValue(flag, isToggled)
        			-- Fallback to EzUI.Flags
        			elseif EzUI and EzUI.Flags then
        				EzUI.Flags[flag] = isToggled
        				-- Auto-save if enabled
        				if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
        					saveConfiguration(EzUI.Configuration.FileName)
        				end
        			end
        		end

        		-- Call user callback
        		local success, errorMsg = pcall(function()
        			callback(isToggled)
        		end)

        		if not success then
        			warn("Toggle callback error:", errorMsg)
        		end
        	end

        	toggleButton.MouseButton1Click:Connect(handleToggle)

        	-- Also allow clicking the background to toggle
        	toggleBg.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 then
        			handleToggle()
        		end
        	end)

        	-- Hover effects
        	toggleButton.MouseEnter:Connect(function()
        		toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	end)

        	toggleButton.MouseLeave:Connect(function()
        		toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	end)

        	-- Return Toggle API
        	local toggleAPI = {}

        	toggleAPI.SetValue = function(newValue)
        		if type(newValue) == "boolean" and newValue ~= isToggled then
        			isToggled = newValue
        			updateToggleAppearance()

        			-- Save to configuration
        			if flag then
        				-- Check if using custom config object
        				if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
        					EzUIConfig.SetValue(flag, isToggled)
        				-- Fallback to EzUI.Flags
        				elseif EzUI and EzUI.Flags then
        					EzUI.Flags[flag] = isToggled
        					-- Auto-save if enabled
        					if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
        						saveConfiguration(EzUI.Configuration.FileName)
        					end
        				end
        			end
        		end
        	end

        	toggleAPI.GetValue = function()
        		return isToggled
        	end

        	toggleAPI.SetText = function(newText)
        		text = newText
        		toggleLabel.Text = newText
        	end

        	toggleAPI.SetCallback = function(newCallback)
        		callback = newCallback or function() end
        	end

        	toggleAPI.Set = toggleAPI.SetValue

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, toggleAPI)
        	end

        	return toggleAPI
        end

        return Toggle

    end

    -- Module: components/window
    EmbeddedModules["components/window"] = function()
        --[[
        	Window Component
        	EzUI Library - Modular Component

        	Creates main window with responsive sizing and dragging
        ]]

        local Window = {}
        local Colors
        local Accordion
        local Button
        local Label
        local NumberBox
        local SelectBox
        local Separator
        local Tab
        local TextBox
        local Toggle

        function Window:Init(_colors, _accordion, _button, _label, _numberbox, _selectbox, _separator, _tab, _textbox, _toggle)
            Colors = _colors
            Accordion = _accordion
            Button = _button
            Label = _label
            NumberBox = _numberbox
            SelectBox = _selectbox
            Separator = _separator
            Tab = _tab
            TextBox = _textbox
            Toggle = _toggle

            -- Debug: Verify Colors module is loaded
            if not Colors then
                warn("Window:Init() - Colors module is nil!")
            elseif not Colors.Background then
                warn("Window:Init() - Colors module missing Background property!")
            end
        end

        function Window:GetViewportSize()
        	local camera = workspace.CurrentCamera
        	if not camera then
        		camera = workspace:WaitForChild("CurrentCamera", 5)
        	end

        	local viewportSize = camera.ViewportSize

        	if viewportSize.X <= 1 or viewportSize.Y <= 1 then
        		viewportSize = Vector2.new(1366, 768)
        		warn("EzUI: Using fallback viewport size:", viewportSize)
        	end

        	return viewportSize
        end

        function Window:CalculateDynamicSize(width, height)
        	local viewportSize = self:GetViewportSize()

        	local baseWidth = width or (viewportSize.X * 0.7)
        	local baseHeight = height or (viewportSize.Y * 0.4)

        	local scaleMultiplier = 1
        	if viewportSize.X >= 1920 then
        		scaleMultiplier = 1.2
        	elseif viewportSize.X >= 1366 then
        		scaleMultiplier = 1.0
        	elseif viewportSize.X >= 1024 then
        		scaleMultiplier = 0.9
        	else
        		scaleMultiplier = 0.8
        	end

        	local finalWidth = math.max(300, math.min(viewportSize.X * 0.8, baseWidth * scaleMultiplier))
        	local finalHeight = math.max(200, math.min(viewportSize.Y * 0.8, baseHeight * scaleMultiplier))

        	return finalWidth, finalHeight
        end

        function Window:CreateFloatingButton(screenGui, frame, toggleMinimizeCallback)
        	-- Create floating button (hidden by default)
        	local floatingButton = Instance.new("Frame")
        	floatingButton.Size = UDim2.new(0, 50, 0, 50)
        	floatingButton.Position = UDim2.new(0, 0, 0.5, -25) -- Middle left by default
        	floatingButton.BackgroundColor3 = Colors.Background.Primary
        	floatingButton.BorderSizePixel = 0
        	floatingButton.ZIndex = 100
        	floatingButton.Visible = false
        	floatingButton.Active = true
        	floatingButton.Parent = screenGui

        	-- Rounded corners for floating button
        	local floatingCorner = Instance.new("UICorner")
        	floatingCorner.CornerRadius = UDim.new(0, 12)
        	floatingCorner.Parent = floatingButton

        	-- Arrow icon
        	local arrowIcon = Instance.new("TextLabel")
        	arrowIcon.Size = UDim2.new(1, 0, 1, 0)
        	arrowIcon.Position = UDim2.new(0, 0, 0, 0)
        	arrowIcon.BackgroundTransparency = 1
        	arrowIcon.Text = ">"
        	arrowIcon.TextColor3 = Colors.Text.Primary
        	arrowIcon.TextSize = 24
        	arrowIcon.Font = Enum.Font.SourceSansBold
        	arrowIcon.TextXAlignment = Enum.TextXAlignment.Center
        	arrowIcon.TextYAlignment = Enum.TextYAlignment.Center
        	arrowIcon.ZIndex = 101
        	arrowIcon.Parent = floatingButton

        	-- Click detector for floating button
        	local floatingClickButton = Instance.new("TextButton")
        	floatingClickButton.Size = UDim2.new(1, 0, 1, 0)
        	floatingClickButton.BackgroundTransparency = 1
        	floatingClickButton.Text = ""
        	floatingClickButton.ZIndex = 102
        	floatingClickButton.Parent = floatingButton

        	-- Shadow effect for floating button
        	local floatingShadow = Instance.new("Frame")
        	floatingShadow.Size = UDim2.new(1, 4, 1, 4)
        	floatingShadow.Position = UDim2.new(0, -2, 0, -2)
        	floatingShadow.BackgroundColor3 = Colors.Background.Overlay
        	floatingShadow.BackgroundTransparency = 0.8
        	floatingShadow.BorderSizePixel = 0
        	floatingShadow.ZIndex = 99
        	floatingShadow.Parent = floatingButton

        	local shadowCorner = Instance.new("UICorner")
        	shadowCorner.CornerRadius = UDim.new(0, 12)
        	shadowCorner.Parent = floatingShadow

        	-- Hover effects for floating button
        	local originalColor = Colors.Background.Primary
        	floatingClickButton.MouseEnter:Connect(function()
        		floatingButton.BackgroundColor3 = Colors.Background.Secondary
        	end)

        	floatingClickButton.MouseLeave:Connect(function()
        		floatingButton.BackgroundColor3 = originalColor
        	end)

        	-- Dragging functionality for floating button
        	local floatingDragging = false
        	local floatingDragInput, floatingDragStart, floatingStartPos
        	local isOnLeftSide = true -- Track which side the button is on

        	local function snapFloatingButton()
        		-- Get viewport size
        		local viewportSize = Window:GetViewportSize()
        		local currentPos = floatingButton.AbsolutePosition
        		local buttonWidth = floatingButton.AbsoluteSize.X
        		local buttonHeight = floatingButton.AbsoluteSize.Y

        		-- Determine which side is closer (left or right)
        		local distanceToLeft = currentPos.X
        		local distanceToRight = viewportSize.X - (currentPos.X + buttonWidth)

        		local targetX, targetY
        		local offsetAmount = 15 -- How much to offset off-screen

        		if distanceToLeft < distanceToRight then
        			-- Snap to left side - slightly off-screen
        			targetX = -offsetAmount
        			isOnLeftSide = true
        			arrowIcon.Text = ">"
        		else
        			-- Snap to right side - slightly off-screen
        			targetX = viewportSize.X - buttonWidth + offsetAmount
        			isOnLeftSide = false
        			arrowIcon.Text = "<"
        		end

        		-- Keep Y position but clamp to viewport bounds
        		targetY = math.max(10, math.min(viewportSize.Y - buttonHeight - 10, currentPos.Y))

        		-- Animate to snapped position
        		floatingButton:TweenPosition(
        			UDim2.new(0, targetX, 0, targetY),
        			Enum.EasingDirection.Out,
        			Enum.EasingStyle.Quad,
        			0.3,
        			true
        		)
        	end

        	local function updateFloatingDrag(input)
        		local delta = input.Position - floatingDragStart
        		local newPos = UDim2.new(
        			floatingStartPos.X.Scale,
        			floatingStartPos.X.Offset + delta.X,
        			floatingStartPos.Y.Scale,
        			floatingStartPos.Y.Offset + delta.Y
        		)
        		floatingButton.Position = newPos
        	end

        	floatingClickButton.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			floatingDragging = true
        			floatingDragStart = input.Position
        			floatingStartPos = floatingButton.Position

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					floatingDragging = false
        					-- Snap to nearest side when drag ends
        					snapFloatingButton()
        				end
        			end)
        		end
        	end)

        	floatingClickButton.InputChanged:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseMovement or
        		   input.UserInputType == Enum.UserInputType.Touch then
        			floatingDragInput = input
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if floatingDragging and input == floatingDragInput then
        			updateFloatingDrag(input)
        		end
        	end)

        	-- Click detection for restore window
        	local clickStartTime = 0
        	local clickStartPos = Vector2.new(0, 0)

        	floatingClickButton.MouseButton1Down:Connect(function()
        		clickStartTime = tick()
        		clickStartPos = Vector2.new(floatingButton.AbsolutePosition.X, floatingButton.AbsolutePosition.Y)
        	end)

        	floatingClickButton.MouseButton1Up:Connect(function()
        		local clickDuration = tick() - clickStartTime
        		local currentPos = Vector2.new(floatingButton.AbsolutePosition.X, floatingButton.AbsolutePosition.Y)
        		local dragDistance = (currentPos - clickStartPos).Magnitude

        		-- Only toggle if it was a quick click (< 0.2s) and minimal drag (< 5 pixels)
        		if clickDuration < 0.2 and dragDistance < 5 then
        			toggleMinimizeCallback()
        		end
        	end)

        	return {
        		Frame = floatingButton,
        		SnapToEdge = snapFloatingButton
        	}
        end

        function Window:SetupMinimizeToggle(frame, floatingButton, originalPosition)
        	local isMinimized = false

        	local function toggleMinimize()
        		isMinimized = not isMinimized

        		if isMinimized then
        			-- Minimize: hide window and show floating button
        			originalPosition = frame.Position
        			frame.Visible = false

        			-- Show floating button with animation
        			floatingButton.Frame.Visible = true
        			floatingButton.Frame.Size = UDim2.new(0, 0, 0, 50)
        			floatingButton.Frame:TweenSize(
        				UDim2.new(0, 50, 0, 50),
        				Enum.EasingDirection.Out,
        				Enum.EasingStyle.Quad,
        				0.3,
        				true,
        				function()
        					-- Snap to side after appearing
        					floatingButton.SnapToEdge()
        				end
        			)
        		else
        			-- Restore: hide floating button and show window
        			floatingButton.Frame:TweenSize(
        				UDim2.new(0, 0, 0, 50),
        				Enum.EasingDirection.In,
        				Enum.EasingStyle.Quad,
        				0.2,
        				true,
        				function()
        					floatingButton.Frame.Visible = false
        					frame.Visible = true
        					frame.Position = originalPosition
        				end
        			)
        		end
        	end

        	return {
        		Toggle = toggleMinimize,
        		IsMinimized = function() return isMinimized end
        	}
        end

        function Window:CreateResizeHandle(frame, minWidth, minHeight, maxWidth, maxHeight)
        	-- Create resize handle in bottom-right corner
        	local resizeHandle = Instance.new("ImageButton")
        	resizeHandle.Size = UDim2.new(0, 20, 0, 20)
        	resizeHandle.Position = UDim2.new(1, -20, 1, -20)
        	resizeHandle.BackgroundColor3 = Colors.Accent.Primary
        	resizeHandle.BackgroundTransparency = 0.7
        	resizeHandle.BorderSizePixel = 0
            resizeHandle.Image = "rbxassetid://16898613613"
            resizeHandle.ImageRectOffset = Vector2.new(820,196)
        	resizeHandle.ImageRectSize = Vector2.new(48, 48) 
        	resizeHandle.ZIndex = 10
        	resizeHandle.Active = true
        	resizeHandle.Parent = frame

        	-- Corner radius
        	local handleCorner = Instance.new("UICorner")
        	handleCorner.CornerRadius = UDim.new(0, 4)
        	handleCorner.Parent = resizeHandle

        	-- Hover effect
        	resizeHandle.MouseEnter:Connect(function()
        		resizeHandle.BackgroundTransparency = 0.3
        	end)

        	resizeHandle.MouseLeave:Connect(function()
        		resizeHandle.BackgroundTransparency = 0.7
        	end)

        	-- Resize functionality
        	local resizing = false
        	local resizeStart, startSize

        	resizeHandle.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			resizing = true
        			resizeStart = input.Position
        			startSize = frame.AbsoluteSize

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					resizing = false
        				end
        			end)
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or 
        		   input.UserInputType == Enum.UserInputType.Touch) then
        			local delta = input.Position - resizeStart

        			-- Calculate new size
        			local newWidth = startSize.X + delta.X
        			local newHeight = startSize.Y + delta.Y

        			-- Apply min/max constraints
        			newWidth = math.max(minWidth or 300, newWidth)
        			newHeight = math.max(minHeight or 200, newHeight)

        			if maxWidth then
        				newWidth = math.min(maxWidth, newWidth)
        			end

        			if maxHeight then
        				newHeight = math.min(maxHeight, newHeight)
        			end

        			-- Update frame size
        			frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        		end
        	end)

        	return resizeHandle
        end

        function Window:CreateTabPanelResizer(tabPanel, scrollFrame, minTabWidth, maxTabWidth)
        	-- Create resize handle on right edge of tab panel
        	local resizer = Instance.new("Frame")
        	resizer.Size = UDim2.new(0, 4, 1, 0)
        	resizer.Position = UDim2.new(1, 0, 0, 0)
        	resizer.BackgroundColor3 = Colors.Accent.Primary
        	resizer.BackgroundTransparency = 0.9
        	resizer.BorderSizePixel = 0
        	resizer.ZIndex = 10
        	resizer.Active = true
        	resizer.Parent = tabPanel

        	-- Visual indicator (appears on hover)
        	local indicator = Instance.new("Frame")
        	indicator.Size = UDim2.new(0, 2, 1, 0)
        	indicator.Position = UDim2.new(0, 1, 0, 0)
        	indicator.BackgroundColor3 = Colors.Accent.Primary
        	indicator.BackgroundTransparency = 1
        	indicator.BorderSizePixel = 0
        	indicator.ZIndex = 11
        	indicator.Parent = resizer

        	-- Hover effects
        	resizer.MouseEnter:Connect(function()
        		resizer.BackgroundTransparency = 0.7
        		indicator.BackgroundTransparency = 0
        	end)

        	resizer.MouseLeave:Connect(function()
        		resizer.BackgroundTransparency = 0.9
        		indicator.BackgroundTransparency = 1
        	end)

        	-- Resize functionality
        	local resizing = false
        	local resizeStart, startWidth

        	resizer.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			resizing = true
        			resizeStart = input.Position
        			startWidth = tabPanel.AbsoluteSize.X

        			-- Show indicator while resizing
        			indicator.BackgroundTransparency = 0

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					resizing = false
        					indicator.BackgroundTransparency = 1
        				end
        			end)
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or 
        		   input.UserInputType == Enum.UserInputType.Touch) then
        			local delta = input.Position - resizeStart

        			-- Calculate new width
        			local newWidth = startWidth + delta.X

        			-- Apply constraints
        			newWidth = math.max(minTabWidth or 80, newWidth)
        			newWidth = math.min(maxTabWidth or 300, newWidth)

        			-- Update tab panel width
        			tabPanel.Size = UDim2.new(0, newWidth, 1, -30)

        			-- Update scroll frame position and size
        			scrollFrame.Position = UDim2.new(0, newWidth, 0, 30)
        			scrollFrame.Size = UDim2.new(1, -newWidth, 1, -30)
        		end
        	end)

        	return resizer
        end

        function Window:Create(config)
        	-- Ensure Colors is initialized with detailed error
        	if not Colors then
        		error("Window:Create() - Colors module is nil. Window:Init() may not have been called or Colors parameter was nil.")
        	end

        	if not Colors.Background then
        		error("Window:Create() - Colors.Background is nil. The Colors module may not have loaded correctly.")
        	end

        	local title = config.Title or "EzUI Window"
        	local width = config.Width
        	local height = config.Height
        	local opacity = config.Opacity or 0.9
        	local autoShow = config.AutoShow ~= nil and config.AutoShow or true
        	local draggable = config.Draggable ~= nil and config.Draggable or true
        	local resizable = config.Resizable ~= nil and config.Resizable or true
        	local tabPanelResizable = config.TabPanelResizable ~= nil and config.TabPanelResizable or true
        	local backgroundColor = config.BackgroundColor or Colors.Background.Secondary
        	local cornerRadius = config.CornerRadius or 8
        	local minWidth = config.MinWidth or 300
        	local minHeight = config.MinHeight or 200
        	local maxWidth = config.MaxWidth
        	local maxHeight = config.MaxHeight
        	local tabPanelWidth = config.TabPanelWidth or 100
        	local minTabPanelWidth = config.MinTabPanelWidth or 80
        	local maxTabPanelWidth = config.MaxTabPanelWidth or 300

        	opacity = math.max(0.1, math.min(1.0, opacity))

        	local screenGui = Instance.new("ScreenGui")
        	screenGui.Name = title
        	screenGui.ResetOnSpawn = false
        	screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

        	local windowWidth, windowHeight = self:CalculateDynamicSize(width, height)

        	-- Main window frame
        	local frame = Instance.new("Frame")
        	frame.Size = UDim2.new(0, windowWidth, 0, windowHeight)
        	frame.Position = UDim2.new(0.5, -windowWidth / 2, 0.5, -windowHeight / 2)
        	frame.BackgroundColor3 = backgroundColor
        	frame.BackgroundTransparency = 1 - opacity
        	frame.BorderSizePixel = 0
        	frame.Active = true
        	frame.ClipsDescendants = true
        	frame.ZIndex = 1
        	frame.Visible = autoShow
        	frame.Parent = screenGui

        	-- Rounded corners
        	local frameCorner = Instance.new("UICorner")
        	frameCorner.CornerRadius = UDim.new(0, cornerRadius)
        	frameCorner.Parent = frame

        	-- Title bar
        	local titleBar = Instance.new("Frame")
        	titleBar.Size = UDim2.new(1, 0, 0, 30)
        	titleBar.Position = UDim2.new(0, 0, 0, 0)
        	titleBar.BackgroundColor3 = Colors.Background.Primary
        	titleBar.BorderSizePixel = 0
        	titleBar.ZIndex = 2
        	titleBar.Parent = frame

        	-- Title bar rounded corners (top only)
        	local titleCorner = Instance.new("UICorner")
        	titleCorner.CornerRadius = UDim.new(0, cornerRadius)
        	titleCorner.Parent = titleBar

        	-- Title text
        	local titleLabel = Instance.new("TextLabel")
        	titleLabel.Size = UDim2.new(1, -70, 1, 0)
        	titleLabel.Position = UDim2.new(0, 10, 0, 0)
        	titleLabel.BackgroundTransparency = 1
        	titleLabel.Text = title
        	titleLabel.TextColor3 = Colors.Text.Primary
        	titleLabel.TextSize = 16
        	titleLabel.Font = Enum.Font.SourceSansBold
        	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        	titleLabel.ZIndex = 3
        	titleLabel.Parent = titleBar

        	-- Minimize button
        	local minimizeBtn = Instance.new("TextButton")
        	minimizeBtn.Size = UDim2.new(0, 30, 0, 30)
        	minimizeBtn.Position = UDim2.new(1, -60, 0, 0)
        	minimizeBtn.BackgroundTransparency = 1
        	minimizeBtn.Text = "−"
        	minimizeBtn.TextColor3 = Colors.Text.Primary
        	minimizeBtn.TextSize = 24
        	minimizeBtn.Font = Enum.Font.SourceSansBold
        	minimizeBtn.ZIndex = 3
        	minimizeBtn.Parent = titleBar

        	minimizeBtn.MouseEnter:Connect(function()
        		minimizeBtn.TextColor3 = Colors.Accent.Primary
        	end)

        	minimizeBtn.MouseLeave:Connect(function()
        		minimizeBtn.TextColor3 = Colors.Text.Primary
        	end)

        	-- Close button
        	local closeBtn = Instance.new("TextButton")
        	closeBtn.Size = UDim2.new(0, 30, 0, 30)
        	closeBtn.Position = UDim2.new(1, -30, 0, 0)
        	closeBtn.BackgroundTransparency = 1
        	closeBtn.Text = "×"
        	closeBtn.TextColor3 = Colors.Text.Primary
        	closeBtn.TextSize = 24
        	closeBtn.Font = Enum.Font.SourceSansBold
        	closeBtn.ZIndex = 3
        	closeBtn.Parent = titleBar

        	closeBtn.MouseEnter:Connect(function()
        		closeBtn.TextColor3 = Colors.Status.Error
        	end)

        	closeBtn.MouseLeave:Connect(function()
        		closeBtn.TextColor3 = Colors.Text.Primary
        	end)

        	closeBtn.MouseButton1Click:Connect(function()
        		screenGui:Destroy()
        	end)

        	-- Tab panel (left side)
        	local tabPanel = Instance.new("Frame")
        	tabPanel.Size = UDim2.new(0, tabPanelWidth, 1, -30)
        	tabPanel.Position = UDim2.new(0, 0, 0, 30)
        	tabPanel.BackgroundColor3 = Colors.Background.Primary
        	tabPanel.BorderSizePixel = 0
        	tabPanel.ZIndex = 2
        	tabPanel.Parent = frame

        	-- Tab scroll frame
        	local tabScrollFrame = Instance.new("ScrollingFrame")
        	tabScrollFrame.Size = UDim2.new(1, 0, 1, 0)
        	tabScrollFrame.Position = UDim2.new(0, 0, 0, 0)
        	tabScrollFrame.BackgroundTransparency = 1
        	tabScrollFrame.BorderSizePixel = 0
        	tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	tabScrollFrame.ScrollBarThickness = 6
        	tabScrollFrame.ScrollBarImageColor3 = Colors.Scrollbar.Thumb
        	tabScrollFrame.ZIndex = 3
        	tabScrollFrame.Parent = tabPanel

        	-- List layout for tabs
        	local tabListLayout = Instance.new("UIListLayout")
        	tabListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	tabListLayout.Padding = UDim.new(0, 3)
        	tabListLayout.Parent = tabScrollFrame

        	-- Content scroll frame
        	local scrollFrame = Instance.new("ScrollingFrame")
        	scrollFrame.Size = UDim2.new(1, -tabPanelWidth, 1, -30)
        	scrollFrame.Position = UDim2.new(0, tabPanelWidth, 0, 30)
        	scrollFrame.BackgroundTransparency = 1
        	scrollFrame.BorderSizePixel = 0
        	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	scrollFrame.ScrollBarThickness = 8
        	scrollFrame.ScrollBarImageColor3 = Colors.Scrollbar.Thumb
        	scrollFrame.ClipsDescendants = false
        	scrollFrame.ZIndex = 2
        	scrollFrame.Parent = frame

        	-- Dragging functionality
        	if draggable then
        		local dragging = false
        		local dragInput, dragStart, startPos

        		local function update(input)
        			local delta = input.Position - dragStart
        			frame.Position = UDim2.new(
        				startPos.X.Scale,
        				startPos.X.Offset + delta.X,
        				startPos.Y.Scale,
        				startPos.Y.Offset + delta.Y
        			)
        		end

        		titleBar.InputBegan:Connect(function(input)
        			if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        			   input.UserInputType == Enum.UserInputType.Touch then
        				dragging = true
        				dragStart = input.Position
        				startPos = frame.Position

        				input.Changed:Connect(function()
        					if input.UserInputState == Enum.UserInputState.End then
        						dragging = false
        					end
        				end)
        			end
        		end)

        		titleBar.InputChanged:Connect(function(input)
        			if input.UserInputType == Enum.UserInputType.MouseMovement or
        			   input.UserInputType == Enum.UserInputType.Touch then
        				dragInput = input
        			end
        		end)

        		game:GetService("UserInputService").InputChanged:Connect(function(input)
        			if dragging and input == dragInput then
        				update(input)
        			end
        		end)
        	end

        	-- Resize functionality
        	local resizeHandle = nil
        	if resizable then
        		resizeHandle = self:CreateResizeHandle(frame, minWidth, minHeight, maxWidth, maxHeight)
        	end

        	-- Tab panel resize functionality
        	local tabPanelResizer = nil
        	if tabPanelResizable then
        		tabPanelResizer = self:CreateTabPanelResizer(tabPanel, scrollFrame, minTabPanelWidth, maxTabPanelWidth)
        	end

        	-- Tab management
        	local tabs = {}
        	local currentTab = nil
        	local tabCount = 0
        	local originalHeight = windowHeight
        	local originalPosition = frame.Position

        	-- Setup minimize/restore functionality (create control first)
        	local minimizeControl = {
        		Toggle = nil,
        		IsMinimized = nil
        	}

        	-- Create floating button with toggle callback
        	local floatingButton = self:CreateFloatingButton(screenGui, frame, function()
        		if minimizeControl.Toggle then
        			minimizeControl.Toggle()
        		end
        	end)

        	-- Now create the actual minimize control
        	local actualMinimizeControl = self:SetupMinimizeToggle(frame, floatingButton, originalPosition)
        	minimizeControl.Toggle = actualMinimizeControl.Toggle
        	minimizeControl.IsMinimized = actualMinimizeControl.IsMinimized

        	-- Connect minimize button
        	minimizeBtn.MouseButton1Click:Connect(minimizeControl.Toggle)

        	-- Keyboard shortcut for toggle minimize (Ctrl + M or Ctrl + H)
        	local UserInputService = game:GetService("UserInputService")
        	UserInputService.InputBegan:Connect(function(input, gameProcessed)
        		-- Don't trigger if user is typing in a text box
        		if gameProcessed then return end

        		-- Check for Ctrl + M or Ctrl + H
        		if input.KeyCode == Enum.KeyCode.M or input.KeyCode == Enum.KeyCode.H then
        			if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or 
        			   UserInputService:IsKeyDown(Enum.KeyCode.RightControl) then
        				minimizeControl.Toggle()
        			end
        		end
        	end)

        	-- Window API
        	local windowAPI = {
        		ScreenGui = screenGui,
        		Frame = frame,
        		TitleBar = titleBar,
        		TabScrollFrame = tabScrollFrame,
        		ScrollFrame = scrollFrame,
        		TabPanel = tabPanel,
        		FloatingButton = floatingButton.Frame,
        		ResizeHandle = resizeHandle,
        		TabPanelResizer = tabPanelResizer,

        		Show = function()
        			if minimizeControl.IsMinimized() then
        				minimizeControl.Toggle()
        			else
        				frame.Visible = true
        			end
        		end,

        		Hide = function()
        			if minimizeControl.IsMinimized() then
        				floatingButton.Frame.Visible = false
        			end
        			frame.Visible = false
        		end,

        		Toggle = function()
        			frame.Visible = not frame.Visible
        		end,

        		Minimize = function()
        			if not minimizeControl.IsMinimized() then
        				minimizeControl.Toggle()
        			end
        		end,

        		Restore = function()
        			if minimizeControl.IsMinimized() then
        				minimizeControl.Toggle()
        			end
        		end,

        		ToggleMinimize = function()
        			minimizeControl.Toggle()
        		end,

        		IsMinimized = function()
        			return minimizeControl.IsMinimized()
        		end,

        		Destroy = function()
        			screenGui:Destroy()
        		end,

        		SetTitle = function(newTitle)
        			titleLabel.Text = newTitle
        			title = newTitle
        		end,

        		SetSize = function(newWidth, newHeight)
        			windowWidth = newWidth
        			originalHeight = newHeight
        			frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        		end,

        		SetPosition = function(x, y)
        			frame.Position = UDim2.new(0, x, 0, y)
        		end,

        		Center = function()
        			local viewportSize = Window:GetViewportSize()
        			local size = frame.AbsoluteSize
        			frame.Position = UDim2.new(
        				0, (viewportSize.X - size.X) / 2,
        				0, (viewportSize.Y - size.Y) / 2
        			)
        		end,

        		SetResizable = function(enabled)
        			if resizeHandle then
        				resizeHandle.Visible = enabled
        			end
        		end,

        		GetSize = function()
        			return frame.AbsoluteSize
        		end,

        		SetTabPanelWidth = function(newWidth)
        			newWidth = math.max(minTabPanelWidth, math.min(maxTabPanelWidth, newWidth))
        			tabPanel.Size = UDim2.new(0, newWidth, 1, -30)
        			scrollFrame.Position = UDim2.new(0, newWidth, 0, 30)
        			scrollFrame.Size = UDim2.new(1, -newWidth, 1, -30)
        		end,

        		GetTabPanelWidth = function()
        			return tabPanel.AbsoluteSize.X
        		end,

        		SetTabPanelResizable = function(enabled)
        			if tabPanelResizer then
        				tabPanelResizer.Visible = enabled
        			end
        		end,

        		AddTab = function(config)
        			-- Handle string shortcut
        			if type(config) == "string" then
        				config = {Name = config}
        			end

        			-- Validate config
        			if type(config) ~= "table" then
        				warn("EzUI Window.AddTab: config must be a string or table")
        				return nil
        			end

        			local tabName = config.Name or "Tab " .. (tabCount + 1)
        			local icon = config.Icon or ""

        			-- Create the tab using Tab component
        			local tabConfig = {
        				Name = tabName,
        				Icon = icon,
        				Parent = tabScrollFrame,
        				ContentParent = scrollFrame,
        				ScreenGui = screenGui
        			}

        			local tabAPI = Tab:Create(tabConfig)

        			if not tabAPI then
        				warn("EzUI Window.AddTab: Failed to create tab")
        				return nil
        			end

        			-- Store tab reference
        			tabCount = tabCount + 1
        			tabs[tabCount] = tabAPI

        			-- Auto-select first tab
        			if tabCount == 1 then
        				currentTab = tabAPI
        				tabAPI:Select()
        			end

        			-- Update tab scroll canvas size
        			tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, tabListLayout.AbsoluteContentSize.Y)

        			return tabAPI
        		end,

        		GetTabs = function()
        			return tabs
        		end,

        		GetCurrentTab = function()
        			return currentTab
        		end,

        		SelectTab = function(index)
        			if tabs[index] then
        				if currentTab then
        					currentTab:Deselect()
        				end
        				currentTab = tabs[index]
        				currentTab:Select()
        			end
        		end
        	}

        	return windowAPI
        end

        return Window

    end

    -- Module: utils/colors
    EmbeddedModules["utils/colors"] = function()
        --[[
        	EzUI Color Palette Module
        	Dark Mode Color Scheme for Roblox GUI

        	Author: EzUI Library
        	Version: 1.0.0

        	Usage:
        		local m = require(path.to.color)
        		myFrame.BackgroundColor3 = Colors.Background.Primary
        		myButton.BackgroundColor3 = Colors.Button.Default
        ]]

        local Colors = {}

        -- ============================================
        -- BACKGROUND COLORS
        -- ============================================
        Colors.Background = {
        	Primary = Color3.fromRGB(30, 30, 35),      -- Main background
        	Secondary = Color3.fromRGB(40, 40, 45),    -- Secondary panels
        	Tertiary = Color3.fromRGB(50, 50, 55),     -- Elevated elements
        	Overlay = Color3.fromRGB(20, 20, 25),      -- Modal overlays
        	Transparent = Color3.fromRGB(0, 0, 0),     -- For transparent elements
        }

        -- ============================================
        -- SURFACE COLORS (Components)
        -- ============================================
        Colors.Surface = {
        	Default = Color3.fromRGB(45, 45, 50),      -- Default surface
        	Elevated = Color3.fromRGB(55, 55, 60),     -- Elevated surface
        	Hover = Color3.fromRGB(60, 60, 65),        -- Hover state
        	Active = Color3.fromRGB(65, 65, 70),       -- Active/Pressed state
        	Disabled = Color3.fromRGB(35, 35, 40),     -- Disabled state
        }

        -- ============================================
        -- TEXT COLORS
        -- ============================================
        Colors.Text = {
        	Primary = Color3.fromRGB(255, 255, 255),   -- Primary text (high contrast)
        	Secondary = Color3.fromRGB(200, 200, 205), -- Secondary text (medium contrast)
        	Tertiary = Color3.fromRGB(150, 150, 155),  -- Tertiary text (low contrast)
        	Disabled = Color3.fromRGB(100, 100, 105),  -- Disabled text
        	Placeholder = Color3.fromRGB(120, 120, 125), -- Placeholder text
        	Link = Color3.fromRGB(100, 150, 255),      -- Link text
        	LinkHover = Color3.fromRGB(120, 170, 255), -- Link hover
        }

        -- ============================================
        -- BORDER COLORS
        -- ============================================
        Colors.Border = {
        	Default = Color3.fromRGB(80, 80, 85),      -- Default border
        	Light = Color3.fromRGB(100, 100, 105),     -- Light border
        	Dark = Color3.fromRGB(60, 60, 65),         -- Dark border
        	Focus = Color3.fromRGB(100, 150, 255),     -- Focused border
        	Error = Color3.fromRGB(255, 100, 100),     -- Error border
        	Success = Color3.fromRGB(100, 255, 150),   -- Success border
        }

        -- ============================================
        -- BUTTON COLORS
        -- ============================================
        Colors.Button = {
        	-- Primary Button
        	Primary = Color3.fromRGB(100, 150, 255),
        	PrimaryHover = Color3.fromRGB(120, 170, 255),
        	PrimaryActive = Color3.fromRGB(80, 130, 235),
        	PrimaryDisabled = Color3.fromRGB(60, 90, 150),

        	-- Secondary Button
        	Secondary = Color3.fromRGB(80, 80, 90),
        	SecondaryHover = Color3.fromRGB(100, 100, 110),
        	SecondaryActive = Color3.fromRGB(70, 70, 80),
        	SecondaryDisabled = Color3.fromRGB(50, 50, 60),

        	-- Success Button
        	Success = Color3.fromRGB(76, 175, 80),
        	SuccessHover = Color3.fromRGB(96, 195, 100),
        	SuccessActive = Color3.fromRGB(56, 155, 60),
        	SuccessDisabled = Color3.fromRGB(46, 115, 50),

        	-- Danger Button
        	Danger = Color3.fromRGB(244, 67, 54),
        	DangerHover = Color3.fromRGB(255, 87, 74),
        	DangerActive = Color3.fromRGB(224, 47, 34),
        	DangerDisabled = Color3.fromRGB(150, 40, 35),

        	-- Warning Button
        	Warning = Color3.fromRGB(255, 193, 7),
        	WarningHover = Color3.fromRGB(255, 213, 27),
        	WarningActive = Color3.fromRGB(235, 173, 0),
        	WarningDisabled = Color3.fromRGB(150, 120, 10),
        }

        -- ============================================
        -- INPUT COLORS (TextBox, SelectBox, etc)
        -- ============================================
        Colors.Input = {
        	Background = Color3.fromRGB(60, 60, 65),
        	BackgroundHover = Color3.fromRGB(70, 70, 75),
        	BackgroundFocus = Color3.fromRGB(65, 65, 70),
        	BackgroundDisabled = Color3.fromRGB(45, 45, 50),
        	Border = Color3.fromRGB(100, 100, 105),
        	BorderFocus = Color3.fromRGB(100, 150, 255),
        	BorderError = Color3.fromRGB(255, 100, 100),
        	Text = Color3.fromRGB(255, 255, 255),
        	Placeholder = Color3.fromRGB(150, 150, 155),
        }

        -- ============================================
        -- TOGGLE/SWITCH COLORS
        -- ============================================
        Colors.Toggle = {
        	On = Color3.fromRGB(76, 175, 80),
        	Off = Color3.fromRGB(100, 100, 100),
        	Handle = Color3.fromRGB(255, 255, 255),
        	Disabled = Color3.fromRGB(70, 70, 75),
        }

        -- ============================================
        -- SLIDER COLORS
        -- ============================================
        Colors.Slider = {
        	Track = Color3.fromRGB(80, 80, 85),
        	TrackFilled = Color3.fromRGB(100, 150, 255),
        	Handle = Color3.fromRGB(255, 255, 255),
        	HandleHover = Color3.fromRGB(245, 245, 245),
        	HandleActive = Color3.fromRGB(230, 230, 230),
        	HandleDisabled = Color3.fromRGB(150, 150, 155),
        }

        -- ============================================
        -- DROPDOWN COLORS
        -- ============================================
        Colors.Dropdown = {
        	Background = Color3.fromRGB(45, 45, 50),
        	Option = Color3.fromRGB(50, 50, 55),
        	OptionHover = Color3.fromRGB(70, 70, 75),
        	OptionSelected = Color3.fromRGB(70, 120, 70),
        	OptionActive = Color3.fromRGB(100, 150, 255),
        	Border = Color3.fromRGB(150, 150, 155),
        	Arrow = Color3.fromRGB(200, 200, 205),
        }

        -- ============================================
        -- SCROLLBAR COLORS
        -- ============================================
        Colors.Scrollbar = {
        	Background = Color3.fromRGB(40, 40, 45),
        	Thumb = Color3.fromRGB(120, 120, 125),
        	ThumbHover = Color3.fromRGB(140, 140, 145),
        	ThumbActive = Color3.fromRGB(160, 160, 165),
        }

        -- ============================================
        -- STATUS COLORS (Semantic m)
        -- ============================================
        Colors.Status = {
        	Success = Color3.fromRGB(76, 175, 80),
        	Warning = Color3.fromRGB(255, 193, 7),
        	Error = Color3.fromRGB(244, 67, 54),
        	Info = Color3.fromRGB(33, 150, 243),
        }

        -- ============================================
        -- ACCENT COLORS
        -- ============================================
        Colors.Accent = {
        	Primary = Color3.fromRGB(100, 150, 255),   -- Blue
        	Secondary = Color3.fromRGB(156, 39, 176),  -- Purple
        	Success = Color3.fromRGB(76, 175, 80),     -- Green
        	Warning = Color3.fromRGB(255, 193, 7),     -- Yellow
        	Danger = Color3.fromRGB(244, 67, 54),      -- Red
        	Info = Color3.fromRGB(33, 150, 243),       -- Light Blue
        }

        -- ============================================
        -- SPECIAL COLORS
        -- ============================================
        Colors.Special = {
        	Shadow = Color3.fromRGB(0, 0, 0),          -- For shadows
        	Highlight = Color3.fromRGB(255, 255, 255), -- For highlights
        	Overlay = Color3.fromRGB(0, 0, 0),         -- For modal overlays (use with transparency)
        	Divider = Color3.fromRGB(80, 80, 85),      -- For separators/dividers
        }

        -- ============================================
        -- TAB COLORS
        -- ============================================
        Colors.Tab = {
        	Background = Color3.fromRGB(50, 50, 50),
        	BackgroundHover = Color3.fromRGB(60, 60, 60),
        	BackgroundActive = Color3.fromRGB(70, 70, 75),
        	Text = Color3.fromRGB(255, 255, 255),
        	TextInactive = Color3.fromRGB(180, 180, 185),
        	Indicator = Color3.fromRGB(100, 150, 255),
        }

        -- ============================================
        -- NOTIFICATION COLORS
        -- ============================================
        Colors.Notification = {
        	Success = {
        		Background = Color3.fromRGB(46, 125, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(76, 175, 80),
        	},
        	Warning = {
        		Background = Color3.fromRGB(245, 127, 23),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(255, 193, 7),
        	},
        	Error = {
        		Background = Color3.fromRGB(211, 47, 47),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(244, 67, 54),
        	},
        	Info = {
        		Background = Color3.fromRGB(25, 118, 210),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(33, 150, 243),
        	},
        }

        -- ============================================
        -- UTILITY FUNCTIONS
        -- ============================================

        -- Convert Color3 to hex string
        function Colors:ToHex(color3)
        	local r = math.floor(color3.R * 255)
        	local g = math.floor(color3.G * 255)
        	local b = math.floor(color3.B * 255)
        	return string.format("#%02X%02X%02X", r, g, b)
        end

        -- Convert hex string to Color3
        function Colors:FromHex(hex)
        	hex = hex:gsub("#", "")
        	local r = tonumber("0x" .. hex:sub(1, 2)) / 255
        	local g = tonumber("0x" .. hex:sub(3, 4)) / 255
        	local b = tonumber("0x" .. hex:sub(5, 6)) / 255
        	return Color3.new(r, g, b)
        end

        -- Lighten a color by a percentage (0-1)
        function Colors:Lighten(color3, amount)
        	amount = math.clamp(amount, 0, 1)
        	local h, s, v = color3:ToHSV()
        	v = math.clamp(v + amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Darken a color by a percentage (0-1)
        function Colors:Darken(color3, amount)
        	amount = math.clamp(amount, 0, 1)
        	local h, s, v = color3:ToHSV()
        	v = math.clamp(v - amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Adjust saturation of a color
        function Colors:Saturate(color3, amount)
        	amount = math.clamp(amount, -1, 1)
        	local h, s, v = color3:ToHSV()
        	s = math.clamp(s + amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Mix two colors with a ratio (0 = color1, 1 = color2)
        function Colors:Mix(color1, color2, ratio)
        	ratio = math.clamp(ratio, 0, 1)
        	return Color3.new(
        		color1.R + (color2.R - color1.R) * ratio,
        		color1.G + (color2.G - color1.G) * ratio,
        		color1.B + (color2.B - color1.B) * ratio
        	)
        end

        -- Get contrasting text color (black or white) based on background
        function Colors:GetContrastText(backgroundColor)
        	local luminance = (0.299 * backgroundColor.R + 0.587 * backgroundColor.G + 0.114 * backgroundColor.B)
        	return luminance > 0.5 and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(255, 255, 255)
        end

        -- Apply alpha/transparency to a color (returns color and transparency value)
        function Colors:WithAlpha(color3, alpha)
        	alpha = math.clamp(alpha, 0, 1)
        	return color3, 1 - alpha
        end

        -- Create a gradient of colors
        function Colors:CreateGradient(startColor, endColor, steps)
        	local gradient = {}
        	for i = 0, steps - 1 do
        		local ratio = i / (steps - 1)
        		table.insert(gradient, Colors.Mix(startColor, endColor, ratio))
        	end
        	return gradient
        end

        -- ============================================
        -- PRESET THEMES
        -- ============================================
        Colors.Themes = {
        	-- Default Dark Theme (already defined above)
        	Dark = {
        		Name = "Dark",
        		Primary = Color3.fromRGB(100, 150, 255),
        		Background = Color3.fromRGB(30, 30, 35),
        		Surface = Color3.fromRGB(45, 45, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Darker Theme
        	Darker = {
        		Name = "Darker",
        		Primary = Color3.fromRGB(100, 150, 255),
        		Background = Color3.fromRGB(15, 15, 20),
        		Surface = Color3.fromRGB(25, 25, 30),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Blue Dark Theme
        	BlueDark = {
        		Name = "Blue Dark",
        		Primary = Color3.fromRGB(33, 150, 243),
        		Background = Color3.fromRGB(18, 32, 47),
        		Surface = Color3.fromRGB(28, 42, 57),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Purple Dark Theme
        	PurpleDark = {
        		Name = "Purple Dark",
        		Primary = Color3.fromRGB(156, 39, 176),
        		Background = Color3.fromRGB(30, 20, 35),
        		Surface = Color3.fromRGB(45, 30, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Green Dark Theme
        	GreenDark = {
        		Name = "Green Dark",
        		Primary = Color3.fromRGB(76, 175, 80),
        		Background = Color3.fromRGB(20, 30, 20),
        		Surface = Color3.fromRGB(30, 45, 30),
        		Text = Color3.fromRGB(255, 255, 255),
        	},
        }

        -- ============================================
        -- RETURN MODULE
        -- ============================================
        return Colors

    end

    -- Module: utils/config
    EmbeddedModules["utils/config"] = function()
        local Config = {}

        function Config:NewConfig(config)
        	-- Support both old style (string, string) and new style (table)
        	local configName, directory

        	if type(config) == "table" then
        		-- New style: table parameter
        		configName = config.ConfigName or config.FileName or config.Name
        		directory = config.Directory or config.FolderName
        	elseif type(config) == "string" then
        		-- Old style: first parameter is configName
        		configName = config
        		directory = nil
        	else
        		warn("EzUI:NewConfig: config must be a string or table")
        		return nil
        	end

        	if not configName or type(configName) ~= "string" then
        		warn("EzUI:NewConfig: configName must be a string")
        		return nil
        	end

        	-- Use custom directory or default to EzUI Configuration folder
        	local customDirectory = directory
        	if customDirectory and type(customDirectory) ~= "string" then
        		warn("EzUI:NewConfig: directory must be a string, using default")
        		customDirectory = nil
        	end

        	-- Create independent storage for this custom config
        	local Flags = {}

        	-- Save function for this custom config
        	local function SaveConfiguration()
        		-- Filter out keys with nil values
        		local dataToSave = {}
        		local hasData = false

        		for key, value in pairs(Flags) do
        			if value ~= nil then
        				dataToSave[key] = value
        				hasData = true
        			end
        		end

        		if not hasData then
        			print("EzUI.CustomConfig: No valid data to save for " .. configName)
        			return false
        		end

        		if not writefile or not isfolder or not makefolder then
        			warn("EzUI.CustomConfig: File operations not available")
        			return false
        		end

        		-- Use custom directory or default to EzUI folder structure
        		local dynamicFolderName, dynamicConfigurationFolder, filePath

        		if customDirectory then
        			-- Custom directory path
        			dynamicFolderName = customDirectory
        			dynamicConfigurationFolder = customDirectory
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		else
        			-- Default EzUI folder structure
        			dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
        			dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		end

        		-- Create folders if they don't exist
        		if not isfolder(dynamicFolderName) then
        			makefolder(dynamicFolderName)
        		end

        		-- Only create Configurations subfolder if not using custom directory
        		if not customDirectory and not isfolder(dynamicConfigurationFolder) then
        			makefolder(dynamicConfigurationFolder)
        		end

        		-- Save to JSON file
        		local success, result = pcall(function()
        			writefile(filePath, HttpService:JSONEncode(dataToSave))
        		end)

        		if success then
        			local savedCount = 0
        			for _ in pairs(dataToSave) do
        				savedCount = savedCount + 1
        			end
        			print("EzUI.CustomConfig: " .. configName .. " saved to " .. filePath .. " (" .. savedCount .. " keys)")
        			return true
        		else
        			warn("EzUI.CustomConfig: Failed to save " .. configName .. ": " .. tostring(result))
        			return false
        		end
        	end

        	-- Load function for this custom config
        	local function LoadConfiguration()
        		if not readfile or not isfile then
        			warn("EzUI.CustomConfig: File operations not available")
        			return false
        		end

        		-- Use custom directory or default to EzUI folder structure
        		local filePath

        		if customDirectory then
        			-- Custom directory path
        			filePath = customDirectory .. "/" .. configName .. ".json"
        		else
        			-- Default EzUI folder structure
        			local dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
        			local dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		end

        		if not isfile(filePath) then
        			print("EzUI.CustomConfig: No file found for " .. configName .. " at " .. filePath)
        			return false
        		end

        		local success, configData = pcall(function()
        			return HttpService:JSONDecode(readfile(filePath))
        		end)

        		if not success then
        			warn("EzUI.CustomConfig: Failed to load " .. configName .. ": " .. tostring(configData))
        			return false
        		end

        		-- Apply loaded data and update components
        		local applied = 0
        		for flagName, flagValue in pairs(configData) do
        			Flags[flagName] = flagValue
        			applied = applied + 1
        		end

        		print("EzUI.CustomConfig: " .. configName .. " loaded (" .. applied .. " settings applied)")
        		return true
        	end

        	-- Return custom configuration object
        	return {
        		-- Get value by key
        		GetValue = function(key)
        			if not key then
        				warn("EzUI.CustomConfig.GetValue: key parameter is required")
        				return nil
        			end
        			return Flags[key]
        		end,

        		-- Set value by key and update associated components
        		SetValue = function(key, value)
        			if not key then
        				warn("EzUI.CustomConfig.SetValue: key parameter is required")
        				return false
        			end

        			Flags[key] = value

        			SaveConfiguration()
        			return true
        		end,

        		-- Get all key-value pairs
        		GetAll = function()
        			local result = {}
        			for key, value in pairs(Flags) do
        				if value ~= nil then
        					result[key] = value
        				end
        			end
        			return result
        		end,

        		-- Get All Keys
        		GetAllKeys = function()
        			local keys = {}
        			for key, value in pairs(Flags) do
        				if value ~= nil then
        					table.insert(keys, key)
        				end
        			end
        			return keys
        		end,

        		-- Delete a specific key
        		DeleteKey = function(key)
        			if not key then
        				warn("EzUI.CustomConfig.DeleteKey: key parameter is required")
        				return false
        			end

        			if Flags[key] ~= nil then
        				Flags[key] = nil

        				SaveConfiguration()
        				return true
        			else
        				warn("EzUI.CustomConfig.DeleteKey: key '" .. key .. "' not found")
        				return false
        			end
        		end,

        		-- Get configuration info
        		GetInfo = function()
        			local folderName, configFolder, filePath

        			if customDirectory then
        				folderName = customDirectory
        				configFolder = customDirectory
        				filePath = customDirectory .. "/" .. configName .. ".json"
        			else
        				folderName = EzUI.Configuration.FolderName or "EzUI"
        				configFolder = folderName .. "/Configurations"
        				filePath = configFolder .. "/" .. configName .. ".json"
        			end

        			return {
        				ConfigName = configName,
        				CustomDirectory = customDirectory,
        				FolderName = folderName,
        				ConfigFolder = configFolder,
        				FilePath = filePath,
        				IsCustomDirectory = customDirectory ~= nil
        			}
        		end,

        		-- Manual save
        		Save = function()
        			return SaveConfiguration()
        		end,

        		-- Manual load
        		Load = function()
        			return LoadConfiguration()
        		end
        	}
        end

        return Config
    end

    -- Module: components/button
    EmbeddedModules["components/button"] = function()
        --[[
        	Button Component
        	EzUI Library - Modular Component

        	Creates a clickable button with hover effects
        ]]
        local Button = {}

        local Colors

        function Button:Init(_colors)
        	Colors = _colors
        end

        function Button:Create(config)
        	local text = config.Text or "Button"
        	local callback = config.Callback or function() end
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false

        	local button = Instance.new("TextButton")
        	if isForAccordion then
        		button.Size = UDim2.new(0, 100, 0, 25)
        		button.Position = UDim2.new(0, 0, 0, currentY)
        		button.BorderColor3 = Colors.Text.Primary
        		button.BorderSizePixel = 2
        		button.TextSize = 12
        		button.ZIndex = 5

        		-- Round corners for accordion button
        		local buttonCorner = Instance.new("UICorner")
        		buttonCorner.CornerRadius = UDim.new(0, 4)
        		buttonCorner.Parent = button

        		-- Button hover effects for accordion
        		button.MouseEnter:Connect(function()
        			button.BackgroundColor3 = Colors.Button.PrimaryHover
        		end)

        		button.MouseLeave:Connect(function()
        			button.BackgroundColor3 = Colors.Button.Primary
        		end)
        	else
        		button.Size = UDim2.new(0, 120, 0, 30)
        		button.Position = UDim2.new(0, 10, 0, currentY)
        		button.BorderSizePixel = 0
        		button.TextSize = 14
        		button.ZIndex = 3
        		button:SetAttribute("ComponentStartY", currentY)
        	end
        	button.BackgroundColor3 = Colors.Button.Primary
        	button.Text = text
        	button.TextColor3 = Colors.Text.Primary
        	button.Font = Enum.Font.SourceSans
        	button.Parent = parentContainer

        	if callback then
        		button.MouseButton1Click:Connect(callback)
        	end

        	-- Create Button API
        	local buttonAPI = {}

        	buttonAPI.SetText = function(newText)
        		button.Text = newText or ""
        	end

        	buttonAPI.GetText = function()
        		return button.Text
        	end

        	buttonAPI.SetCallback = function(newCallback)
        		callback = newCallback or function() end
        		button.MouseButton1Click:Connect(callback)
        	end

        	buttonAPI.SetEnabled = function(enabled)
        		button.Active = enabled
        		if enabled then
        			button.BackgroundColor3 = Colors.Button.Primary
        		else
        			button.BackgroundColor3 = Colors.Button.PrimaryDisabled
        		end
        	end

        	return buttonAPI
        end

        return Button

    end

    -- Module: components/label
    EmbeddedModules["components/label"] = function()
        --[[
        	Label Component
        	EzUI Library - Modular Component

        	Creates a text label with optional dynamic function support
        ]]
        local Label = {}

        local Colors

        function Label:Init(_colors)
            Colors = _colors
        end

        function Label:Create(config)
        	local text = config.Text or ""
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false

        	local label = Instance.new("TextLabel")
        	if isForAccordion then
        		label.Size = UDim2.new(1, 0, 0, 25)
        		label.Position = UDim2.new(0, 0, 0, currentY)
        		label.TextSize = 14
        		label.ZIndex = 5
        	else
        		label.Size = UDim2.new(1, -20, 0, 30)
        		label.Position = UDim2.new(0, 10, 0, currentY)
        		label.TextSize = 16
        		label.ZIndex = 3
        		label:SetAttribute("ComponentStartY", currentY)
        	end
        	label.BackgroundTransparency = 1
        	label.Text = type(text) == "function" and text() or text
        	label.TextColor3 = Colors.Text.Primary
        	label.TextXAlignment = Enum.TextXAlignment.Left
        	label.Font = Enum.Font.SourceSans
        	label.Parent = parentContainer

        	-- Store the text source (function or string)
        	local textSource = text
        	local updateConnection = nil

        	-- Create Label API
        	local labelAPI = {}

        	-- Function to update text from source
        	local function updateText()
        		if type(textSource) == "function" then
        			local success, result = pcall(textSource)
        			if success then
        				label.Text = tostring(result)
        			else
        				warn("Label dynamic text error:", result)
        				label.Text = "[Error]"
        			end
        		else
        			label.Text = tostring(textSource or "")
        		end
        	end

        	labelAPI.SetText = function(newText)
        		textSource = newText
        		updateText()
        	end

        	labelAPI.GetText = function()
        		return label.Text
        	end

        	labelAPI.SetTextColor = function(color)
        		label.TextColor3 = color
        	end

        	labelAPI.SetTextSize = function(size)
        		label.TextSize = size
        	end

        	-- Start auto-update if text is a function
        	labelAPI.StartAutoUpdate = function(interval)
        		interval = interval or 1

        		if updateConnection then
        			updateConnection:Disconnect()
        		end

        		if type(textSource) == "function" then
        			local RunService = game:GetService("RunService")
        			local lastUpdate = 0

        			updateConnection = RunService.Heartbeat:Connect(function()
        				local currentTime = tick()
        				if currentTime - lastUpdate >= interval then
        					updateText()
        					lastUpdate = currentTime
        				end
        			end)
        		end
        	end

        	labelAPI.StopAutoUpdate = function()
        		if updateConnection then
        			updateConnection:Disconnect()
        			updateConnection = nil
        		end
        	end

        	labelAPI.Update = function()
        		updateText()
        	end

        	-- Cleanup when label is destroyed
        	label.AncestryChanged:Connect(function()
        		if not label.Parent then
        			labelAPI.StopAutoUpdate()
        		end
        	end)

        	-- If text is a function, start auto-update by default
        	if type(textSource) == "function" then
        		labelAPI.StartAutoUpdate(1)
        	end

        	return labelAPI
        end

        return Label

    end

    -- Module: components/selectbox
    EmbeddedModules["components/selectbox"] = function()
        --[[
        local Colors = require(game.ReplicatedStorage.utils.colors)
        	SelectBox Component
        	EzUI Library - Modular Component

        	Creates a dropdown select box with search and multi-select support
        	Note: This is a simplified modular version. For full features, use the main UI library.
        ]]
        local SelectBox = {}

        local Colors

        function SelectBox:Init(_colors)
        	Colors = _colors
        end

        function SelectBox:Create(config)
        	local rawOptions = config.Options or {"Option 1", "Option 2", "Option 3"}
        	local placeholder = config.Placeholder or "Select option..."
        	local multiSelect = config.MultiSelect or false
        	local callback = config.Callback or function() end
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local screenGui = config.ScreenGui
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local EzUIConfig = config.EzUIConfig

        	-- Normalize options to {text, value} format
        	local options = {}
        	for i, option in ipairs(rawOptions) do
        		if type(option) == "string" then
        			table.insert(options, {text = option, value = option})
        		elseif type(option) == "table" and option.text and option.value then
        			table.insert(options, option)
        		end
        	end

        	local selectedValues = {}
        	local isOpen = false

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if EzUIConfig and type(EzUIConfig.GetValue) == "function" then
        			flagValue = EzUIConfig.GetValue(flag)
        		-- Fallback to EzUI.Flags
        		elseif EzUI and EzUI.Flags then
        			flagValue = EzUI.Flags[flag]
        		end

        		if flagValue ~= nil then
        			if type(flagValue) == "table" then
        				selectedValues = flagValue
        			elseif flagValue ~= "" then
        				selectedValues = {flagValue}
        			end
        		end
        	end

        	-- Main container
        	local selectContainer = Instance.new("Frame")
        	if isForAccordion then
        		selectContainer.Size = UDim2.new(1, 0, 0, 25)
        		selectContainer.Position = UDim2.new(0, 0, 0, currentY)
        		selectContainer.ZIndex = 6
        	else
        		selectContainer.Size = UDim2.new(1, -20, 0, 25)
        		selectContainer.Position = UDim2.new(0, 10, 0, currentY)
        		selectContainer.ZIndex = 3
        		selectContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	selectContainer.BackgroundTransparency = 1
        	selectContainer.ClipsDescendants = false
        	selectContainer.Parent = parentContainer

        	-- Select button
        	local selectButton = Instance.new("TextButton")
        	selectButton.Size = UDim2.new(1, -25, 1, 0)
        	selectButton.Position = UDim2.new(0, 0, 0, 0)
        	selectButton.BackgroundColor3 = Colors.Dropdown.Option
        	selectButton.BorderColor3 = Colors.Dropdown.Border
        	selectButton.BorderSizePixel = 2
        	selectButton.Text = "  " .. placeholder
        	selectButton.TextColor3 = Colors.Text.Secondary
        	selectButton.TextXAlignment = Enum.TextXAlignment.Left
        	selectButton.Font = Enum.Font.SourceSans
        	selectButton.TextSize = isForAccordion and 12 or 14
        	selectButton.ZIndex = isForAccordion and 7 or 4
        	selectButton.Parent = selectContainer

        	-- Arrow button
        	local arrow = Instance.new("TextButton")
        	arrow.Size = UDim2.new(0, 25, 1, 0)
        	arrow.Position = UDim2.new(1, -25, 0, 0)
        	arrow.BackgroundColor3 = Colors.Surface.Default
        	arrow.BorderColor3 = Colors.Dropdown.Border
        	arrow.BorderSizePixel = 2
        	arrow.Text = "▼"
        	arrow.TextColor3 = Colors.Text.Secondary
        	arrow.Font = Enum.Font.SourceSans
        	arrow.TextSize = 10
        	arrow.ZIndex = isForAccordion and 7 or 4
        	arrow.Parent = selectContainer

        	-- Dropdown frame
        	local dropdownHeight = math.min(#options * 30 + 30, 200)
        	local dropdownFrame = Instance.new("ScrollingFrame")
        	dropdownFrame.Size = UDim2.new(1, 0, 0, dropdownHeight)
        	dropdownFrame.Position = UDim2.new(0, 0, 1, 3)
        	dropdownFrame.BackgroundColor3 = Colors.Dropdown.Background
        	dropdownFrame.BorderColor3 = Colors.Dropdown.Border
        	dropdownFrame.BorderSizePixel = 2
        	dropdownFrame.Visible = false
        	dropdownFrame.CanvasSize = UDim2.new(0, 0, 0, #options * 30 + 30)
        	dropdownFrame.ScrollBarThickness = 6
        	dropdownFrame.ZIndex = 25
        	dropdownFrame.Parent = screenGui or selectContainer.Parent

        	-- Search box
        	local searchBox = Instance.new("TextBox")
        	searchBox.Size = UDim2.new(1, -10, 0, 20)
        	searchBox.Position = UDim2.new(0, 5, 0, 5)
        	searchBox.BackgroundColor3 = Colors.Input.Background
        	searchBox.BorderColor3 = Colors.Input.Border
        	searchBox.BorderSizePixel = 1
        	searchBox.PlaceholderText = "Search..."
        	searchBox.Text = ""
        	searchBox.TextColor3 = Colors.Text.Primary
        	searchBox.Font = Enum.Font.Gotham
        	searchBox.TextSize = 10
        	searchBox.ZIndex = 26
        	searchBox.Parent = dropdownFrame

        	-- Options container
        	local optionsContainer = Instance.new("Frame")
        	optionsContainer.Size = UDim2.new(1, 0, 1, -30)
        	optionsContainer.Position = UDim2.new(0, 0, 0, 30)
        	optionsContainer.BackgroundTransparency = 1
        	optionsContainer.ZIndex = 26
        	optionsContainer.Parent = dropdownFrame

        	-- List layout
        	local listLayout = Instance.new("UIListLayout")
        	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	listLayout.Parent = optionsContainer

        	-- Update display text
        	local function updateDisplayText()
        		if #selectedValues == 0 then
        			selectButton.Text = "  " .. placeholder
        			selectButton.TextColor3 = Colors.Text.Secondary
        		elseif multiSelect and #selectedValues > 1 then
        			selectButton.Text = "  " .. #selectedValues .. " items selected"
        			selectButton.TextColor3 = Colors.Text.Primary
        		else
        			local displayText = selectedValues[1]
        			for _, option in ipairs(options) do
        				if option.value == selectedValues[1] then
        					displayText = option.text
        					break
        				end
        			end
        			selectButton.Text = "  " .. (displayText or "Unknown")
        			selectButton.TextColor3 = Colors.Text.Primary
        		end
        	end

        	-- Calculate dropdown position
        	local function calculateDropdownPosition()
        		local absolutePos = selectContainer.AbsolutePosition
        		local absoluteSize = selectContainer.AbsoluteSize
        		dropdownFrame.Position = UDim2.new(0, absolutePos.X, 0, absolutePos.Y + absoluteSize.Y + 3)
        		dropdownFrame.Size = UDim2.new(0, absoluteSize.X, 0, dropdownHeight)
        	end

        	-- Create options
        	local function refreshOptions()
        		for _, child in pairs(optionsContainer:GetChildren()) do
        			if child:IsA("TextButton") then
        				child:Destroy()
        			end
        		end

        		for i, option in ipairs(options) do
        			local optionButton = Instance.new("TextButton")
        			optionButton.Size = UDim2.new(1, -10, 0, 30)
        			optionButton.BackgroundColor3 = Colors.Dropdown.Option
        			optionButton.BorderSizePixel = 0
        			optionButton.Text = "  " .. option.text
        			optionButton.TextColor3 = Colors.Text.Primary
        			optionButton.TextXAlignment = Enum.TextXAlignment.Left
        			optionButton.Font = Enum.Font.SourceSans
        			optionButton.TextSize = 12
        			optionButton.ZIndex = 27
        			optionButton.Parent = optionsContainer

        			-- Checkmark
        			local checkmark = Instance.new("TextLabel")
        			checkmark.Size = UDim2.new(0, 20, 1, 0)
        			checkmark.Position = UDim2.new(1, -20, 0, 0)
        			checkmark.BackgroundTransparency = 1
        			checkmark.Text = ""
        			checkmark.TextColor3 = Colors.Status.Success
        			checkmark.Font = Enum.Font.SourceSansBold
        			checkmark.TextSize = 12
        			checkmark.ZIndex = 28
        			checkmark.Visible = multiSelect
        			checkmark.Parent = optionButton

        			-- Check if selected
        			local isSelected = false
        			for _, val in ipairs(selectedValues) do
        				if val == option.value then
        					isSelected = true
        					break
        				end
        			end

        			if isSelected then
        				checkmark.Text = "✓"
        				optionButton.BackgroundColor3 = Colors.Dropdown.OptionSelected
        			end

        			-- Click handler
        			optionButton.MouseButton1Click:Connect(function()
        				if multiSelect then
        					local found = false
        					for j, val in ipairs(selectedValues) do
        						if val == option.value then
        							table.remove(selectedValues, j)
        							found = true
        							break
        						end
        					end

        					if not found then
        						table.insert(selectedValues, option.value)
        					end

        					refreshOptions()
        				else
        					selectedValues = {option.value}
        					isOpen = false
        					dropdownFrame.Visible = false
        					arrow.Text = "▼"
        				end

        				updateDisplayText()

        				-- Save to configuration
        				if flag then
        					local valueToSave = multiSelect and selectedValues or (selectedValues[1] or "")

        					-- Check if using custom config object
        					if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
        						EzUIConfig.SetValue(flag, valueToSave)
        					-- Fallback to EzUI.Flags
        					elseif EzUI and EzUI.Flags then
        						EzUI.Flags[flag] = valueToSave
        						-- Auto-save if enabled
        						if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
        							saveConfiguration(EzUI.Configuration.FileName)
        						end
        					end
        				end

        				callback(selectedValues, option.value)
        			end)

        			-- Hover effects
        			optionButton.MouseEnter:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Dropdown.OptionHover
        				end
        			end)

        			optionButton.MouseLeave:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Dropdown.Option
        				end
        			end)
        		end
        	end

        	-- Toggle dropdown
        	local function toggleDropdown()
        		isOpen = not isOpen
        		dropdownFrame.Visible = isOpen
        		arrow.Text = isOpen and "▲" or "▼"

        		if isOpen then
        			calculateDropdownPosition()
        		end
        	end

        	-- Button handlers
        	selectButton.MouseButton1Click:Connect(toggleDropdown)
        	arrow.MouseButton1Click:Connect(toggleDropdown)

        	-- Search filter
        	searchBox:GetPropertyChangedSignal("Text"):Connect(function()
        		local searchText = string.lower(searchBox.Text)
        		for _, child in pairs(optionsContainer:GetChildren()) do
        			if child:IsA("TextButton") then
        				local optionText = string.lower(child.Text)
        				child.Visible = searchText == "" or string.find(optionText, searchText, 1, true) ~= nil
        			end
        		end
        	end)

        	-- Initial setup
        	refreshOptions()
        	updateDisplayText()

        	-- SelectBox API
        	local selectBoxAPI = {
        		GetSelected = function()
        			return selectedValues
        		end,
        		SetSelected = function(values)
        			selectedValues = type(values) == "table" and values or (values ~= "" and {values} or {})
        			refreshOptions()
        			updateDisplayText()
        		end,
        		Clear = function()
        			selectedValues = {}
        			refreshOptions()
        			updateDisplayText()
        		end,
        		Refresh = function(newOptions)
        			rawOptions = newOptions
        			options = {}
        			for i, option in ipairs(rawOptions) do
        				if type(option) == "string" then
        					table.insert(options, {text = option, value = option})
        				elseif type(option) == "table" and option.text and option.value then
        					table.insert(options, option)
        				end
        			end
        			selectedValues = {}
        			refreshOptions()
        			updateDisplayText()
        		end,
        		Set = function(values)
        			selectedValues = type(values) == "table" and values or (values ~= "" and {values} or {})
        			updateDisplayText()
        		end,
        		Cleanup = function()
        			if dropdownFrame then
        				dropdownFrame:Destroy()
        			end
        			if selectContainer then
        				selectContainer:Destroy()
        			end
        		end
        	}

        	-- Register component
        	if registerComponent then
        		registerComponent(flag, selectBoxAPI)
        	end

        	return selectBoxAPI
        end

        return SelectBox

    end

    -- Module: components/tab
    EmbeddedModules["components/tab"] = function()
        --[[
        	Tab Component
        	EzUI Library - Modular Component

        	Creates a tab with icon, title, and content
        ]]
        -- Component modules (will be loaded by Window)

        local Tab = {}

        local Colors
        local Button
        local Toggle
        local TextBox
        local NumberBox
        local SelectBox
        local Label
        local Separator
        local Accordion

        -- Initialize component modules
        function Tab:Init(_colors, _accordion, _button, _toggle, _textbox, _numberbox, _selectbox, _label, _separator)
        	Colors = _colors
        	Accordion = _accordion
        	Button = _button
        	Toggle = _toggle
        	TextBox = _textbox
        	NumberBox = _numberbox
        	SelectBox = _selectbox
        	Label = _label
        	Separator = _separator
        end

        function Tab:Create(config)
        	local tabName = config.Name or config.Title or "New Tab"
        	local tabIcon = config.Icon or nil
        	local tabVisible = config.Visible ~= nil and config.Visible or true
        	local tabCallback = config.Callback or nil
        	local tabScrollFrame = config.TabScrollFrame
        	local tabContents = config.TabContents
        	local scrollFrame = config.ScrollFrame

        	-- Tab button (container)
        	local tabBtn = Instance.new("TextButton")
        	tabBtn.Size = UDim2.new(1, -6, 0, 32)
        	tabBtn.BackgroundColor3 = Colors.Tab.Background
        	tabBtn.Text = ""
        	tabBtn.BorderSizePixel = 0
        	tabBtn.ZIndex = 4
        	tabBtn.Visible = tabVisible
        	tabBtn.Parent = tabScrollFrame

        	-- Icon label (left aligned)
        	local iconLabel = Instance.new("TextLabel")
        	iconLabel.Size = UDim2.new(0, 30, 1, 0)
        	iconLabel.Position = UDim2.new(0, 5, 0, 0)
        	iconLabel.BackgroundTransparency = 1
        	iconLabel.Text = tabIcon or ""
        	iconLabel.TextColor3 = Colors.Tab.Text
        	iconLabel.Font = Enum.Font.SourceSansBold
        	iconLabel.TextSize = 15
        	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
        	iconLabel.ZIndex = 5
        	iconLabel.Parent = tabBtn

        	-- Title label (alignment depends on icon presence)
        	local titleLabel = Instance.new("TextLabel")
        	titleLabel.BackgroundTransparency = 1
        	titleLabel.Text = tabName
        	titleLabel.TextColor3 = Colors.Tab.Text
        	titleLabel.Font = Enum.Font.SourceSansBold
        	titleLabel.TextSize = 15
        	titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
        	titleLabel.ZIndex = 5
        	titleLabel.Parent = tabBtn

        	-- Function to update title alignment based on icon presence
        	local function updateTitleAlignment()
        		if tabIcon and tabIcon ~= "" then
        			titleLabel.Size = UDim2.new(1, -40, 1, 0)
        			titleLabel.Position = UDim2.new(0, 35, 0, 0)
        			titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        			iconLabel.Visible = true
        		else
        			titleLabel.Size = UDim2.new(1, -10, 1, 0)
        			titleLabel.Position = UDim2.new(0, 5, 0, 0)
        			titleLabel.TextXAlignment = Enum.TextXAlignment.Center
        			iconLabel.Visible = false
        		end
        	end

        	-- Initial alignment setup
        	updateTitleAlignment()

        	-- Tab content frame
        	local tabContent = Instance.new("Frame")
        	tabContent.Size = UDim2.new(1, 0, 1, 0)
        	tabContent.Position = UDim2.new(0, 0, 0, 0)
        	tabContent.BackgroundTransparency = 1
        	tabContent.Visible = false
        	tabContent.ClipsDescendants = false
        	tabContent.ZIndex = 2
        	tabContent.Parent = scrollFrame
        	tabContents[tabName] = tabContent

        	-- Track current Y position for components
        	local currentY = 0

        	-- Tab API
        	local tabAPI = {
        		Button = tabBtn,
        		Content = tabContent,
        		Name = tabName,
        		SetIcon = function(newIcon)
        			tabIcon = newIcon
        			iconLabel.Text = newIcon or ""
        			updateTitleAlignment()
        		end,
        		SetTitle = function(newTitle)
        			tabName = newTitle
        			titleLabel.Text = newTitle
        		end,
        		SetVisible = function(visible)
        			tabBtn.Visible = visible
        		end,
        		Show = function()
        			tabContent.Visible = true
        		end,
        		Hide = function()
        			tabContent.Visible = false
        		end,
        		IsVisible = function()
        			return tabContent.Visible
        		end,

        		-- Add Button Component
        		AddButton = function(buttonConfig)
        			if not Button then
        				warn("Tab.AddButton: Button module not initialized")
        				return nil
        			end

        			local btnConfig = type(buttonConfig) == "string" and {Text = buttonConfig} or buttonConfig or {}
        			btnConfig.Parent = tabContent
        			btnConfig.Y = currentY
        			btnConfig.EzUI = config.EzUI
        			btnConfig.SaveConfiguration = config.SaveConfiguration
        			btnConfig.RegisterComponent = config.RegisterComponent

        			local buttonAPI = Button:Create(btnConfig)
        			currentY = currentY + 35

        			return buttonAPI
        		end,

        		-- Add Toggle Component
        		AddToggle = function(toggleConfig)
        			if not Toggle then
        				warn("Tab.AddToggle: Toggle module not initialized")
        				return nil
        			end

        			toggleConfig = toggleConfig or {}
        			toggleConfig.Parent = tabContent
        			toggleConfig.Y = currentY
        			toggleConfig.EzUI = config.EzUI
        			toggleConfig.SaveConfiguration = config.SaveConfiguration
        			toggleConfig.RegisterComponent = config.RegisterComponent
        			toggleConfig.EzUIConfig = config.EzUIConfig

        			local toggleAPI = Toggle:Create(toggleConfig)
        			currentY = currentY + 35

        			return toggleAPI
        		end,

        		-- Add TextBox Component
        		AddTextBox = function(textboxConfig)
        			if not TextBox then
        				warn("Tab.AddTextBox: TextBox module not initialized")
        				return nil
        			end

        			textboxConfig = textboxConfig or {}
        			textboxConfig.Parent = tabContent
        			textboxConfig.Y = currentY
        			textboxConfig.EzUI = config.EzUI
        			textboxConfig.SaveConfiguration = config.SaveConfiguration
        			textboxConfig.RegisterComponent = config.RegisterComponent
        			textboxConfig.EzUIConfig = config.EzUIConfig

        			local textboxAPI = TextBox:Create(textboxConfig)
        			currentY = currentY + 35

        			return textboxAPI
        		end,

        		-- Add NumberBox Component
        		AddNumberBox = function(numberboxConfig)
        			if not NumberBox then
        				warn("Tab.AddNumberBox: NumberBox module not initialized")
        				return nil
        			end

        			numberboxConfig = numberboxConfig or {}
        			numberboxConfig.Parent = tabContent
        			numberboxConfig.Y = currentY
        			numberboxConfig.EzUI = config.EzUI
        			numberboxConfig.SaveConfiguration = config.SaveConfiguration
        			numberboxConfig.RegisterComponent = config.RegisterComponent
        			numberboxConfig.EzUIConfig = config.EzUIConfig

        			local numberboxAPI = NumberBox:Create(numberboxConfig)
        			currentY = currentY + 35

        			return numberboxAPI
        		end,

        		-- Add SelectBox Component
        		AddSelectBox = function(selectboxConfig)
        			if not SelectBox then
        				warn("Tab.AddSelectBox: SelectBox module not initialized")
        				return nil
        			end

        			selectboxConfig = selectboxConfig or {}
        			selectboxConfig.Parent = tabContent
        			selectboxConfig.Y = currentY
        			selectboxConfig.ScreenGui = config.ScreenGui
        			selectboxConfig.EzUI = config.EzUI
        			selectboxConfig.SaveConfiguration = config.SaveConfiguration
        			selectboxConfig.RegisterComponent = config.RegisterComponent
        			selectboxConfig.EzUIConfig = config.EzUIConfig

        			local selectboxAPI = SelectBox:Create(selectboxConfig)
        			currentY = currentY + 30

        			return selectboxAPI
        		end,

        		-- Add Label Component
        		AddLabel = function(labelConfig)
        			if not Label then
        				warn("Tab.AddLabel: Label module not initialized")
        				return nil
        			end

        			local lblConfig = type(labelConfig) == "string" and {Text = labelConfig} or labelConfig or {}
        			lblConfig.Parent = tabContent
        			lblConfig.Y = currentY

        			local labelAPI = Label:Create(lblConfig)
        			currentY = currentY + 25

        			return labelAPI
        		end,

        		-- Add Separator Component
        		AddSeparator = function(separatorConfig)
        			if not Separator then
        				warn("Tab.AddSeparator: Separator module not initialized")
        				return nil
        			end

        			separatorConfig = separatorConfig or {}
        			separatorConfig.Parent = tabContent
        			separatorConfig.Y = currentY

        			local separatorAPI = Separator:Create(separatorConfig)
        			currentY = currentY + 15

        			return separatorAPI
        		end,

        		-- Add Accordion Component
        		AddAccordion = function(accordionConfig)
        			if not Accordion then
        				warn("Tab.AddAccordion: Accordion module not initialized")
        				return nil
        			end

        			accordionConfig = accordionConfig or {}
        			accordionConfig.Parent = tabContent
        			accordionConfig.Y = currentY
        			accordionConfig.ScreenGui = config.ScreenGui
        			accordionConfig.EzUI = config.EzUI
        			accordionConfig.SaveConfiguration = config.SaveConfiguration
        			accordionConfig.RegisterComponent = config.RegisterComponent
        			accordionConfig.EzUIConfig = config.EzUIConfig

        			local accordionAPI = Accordion:Create(accordionConfig)
        			currentY = currentY + 35

        			return accordionAPI
        		end
        	}

        	return tabAPI
        end

        return Tab

    end

    -- Module: components/textbox
    EmbeddedModules["components/textbox"] = function()
        --[[
        	TextBox Component
        	EzUI Library - Modular Component

        	Creates a text input field with character counter
        ]]
        local TextBox = {}

        local Colors

        function TextBox:Init(_colors)
        	Colors = _colors
        end

        function TextBox:Create(config)
        	local placeholder = config.Placeholder or "Enter text..."
        	local defaultText = config.Default or ""
        	local callback = config.Callback or function() end
        	local maxLength = config.MaxLength or 100
        	local multiline = config.Multiline or false
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local EzUIConfig = config.EzUIConfig

        	-- TextBox state
        	local currentText = defaultText

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if EzUIConfig and type(EzUIConfig.GetValue) == "function" then
        			flagValue = EzUIConfig.GetValue(flag)
        		-- Fallback to EzUI.Flags
        		elseif EzUI and EzUI.Flags then
        			flagValue = EzUI.Flags[flag]
        		end

        		if flagValue ~= nil then
        			currentText = flagValue
        			defaultText = currentText
        		end
        	end

        	-- Main textbox container
        	local textBoxContainer = Instance.new("Frame")
        	if isForAccordion then
        		textBoxContainer.Size = UDim2.new(1, -10, 0, multiline and 60 or 25)
        		textBoxContainer.Position = UDim2.new(0, 5, 0, currentY)
        		textBoxContainer.ZIndex = 6
        	else
        		textBoxContainer.Size = UDim2.new(1, -20, 0, multiline and 80 or 30)
        		textBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
        		textBoxContainer.ZIndex = 3
        		textBoxContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	textBoxContainer.BackgroundTransparency = 1
        	textBoxContainer.Parent = parentContainer

        	-- TextBox input
        	local textBox = Instance.new("TextBox")
        	textBox.Size = UDim2.new(1, 0, 1, 0)
        	textBox.Position = UDim2.new(0, 0, 0, 0)
        	textBox.BackgroundColor3 = Colors.Input.Background
        	textBox.BorderColor3 = Colors.Input.Border
        	textBox.BorderSizePixel = 1
        	textBox.Text = defaultText
        	textBox.PlaceholderText = placeholder
        	textBox.TextColor3 = Colors.Input.Text
        	textBox.PlaceholderColor3 = Colors.Text.Tertiary
        	textBox.Font = Enum.Font.SourceSans
        	textBox.TextSize = isForAccordion and 12 or 14
        	textBox.TextXAlignment = Enum.TextXAlignment.Left
        	textBox.TextYAlignment = multiline and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center
        	textBox.MultiLine = multiline
        	textBox.TextWrapped = multiline
        	textBox.ClearTextOnFocus = false
        	textBox.ZIndex = isForAccordion and 7 or 4
        	textBox.Parent = textBoxContainer

        	-- Round corners
        	local corner = Instance.new("UICorner")
        	corner.CornerRadius = UDim.new(0, 4)
        	corner.Parent = textBox

        	-- Character counter (if maxLength is set)
        	local charCounter = nil
        	if maxLength and maxLength > 0 then
        		charCounter = Instance.new("TextLabel")
        		charCounter.Size = UDim2.new(0, 50, 0, 15)
        		charCounter.Position = UDim2.new(1, -55, 1, -18)
        		charCounter.BackgroundTransparency = 1
        		charCounter.Text = string.len(currentText) .. "/" .. maxLength
        		charCounter.TextColor3 = Colors.Text.Tertiary
        		charCounter.Font = Enum.Font.SourceSans
        		charCounter.TextSize = isForAccordion and 10 or 12
        		charCounter.TextXAlignment = Enum.TextXAlignment.Right
        		charCounter.ZIndex = isForAccordion and 8 or 5
        		charCounter.Parent = textBoxContainer
        	end

        	-- Function to update character counter
        	local function updateCharCounter()
        		if charCounter then
        			local textLength = string.len(textBox.Text)
        			charCounter.Text = textLength .. "/" .. maxLength

        			-- Change color based on limit
        			if textLength >= maxLength then
        				charCounter.TextColor3 = Colors.Status.Error
        			elseif textLength >= maxLength * 0.8 then
        				charCounter.TextColor3 = Colors.Status.Warning
        			else
        				charCounter.TextColor3 = Colors.Text.Tertiary
        			end
        		end
        	end

        	-- Text change handler
        	textBox.Changed:Connect(function(property)
        		if property == "Text" then
        			-- Enforce max length
        			if maxLength and maxLength > 0 and string.len(textBox.Text) > maxLength then
        				textBox.Text = string.sub(textBox.Text, 1, maxLength)
        			end

        			currentText = textBox.Text
        			updateCharCounter()

        			-- Save to configuration
        			if flag then
        				-- Check if using custom config object
        				if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
        					EzUIConfig.SetValue(flag, currentText)
        				-- Fallback to EzUI.Flags
        				elseif EzUI and EzUI.Flags then
        					EzUI.Flags[flag] = currentText
        					-- Auto-save if enabled
        					if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
        						saveConfiguration(EzUI.Configuration.FileName)
        					end
        				end
        			end

        			-- Call user callback
        			local success, errorMsg = pcall(function()
        				callback(currentText)
        			end)

        			if not success then
        				warn("TextBox callback error:", errorMsg)
        			end
        		end
        	end)

        	-- Focus effects
        	textBox.Focused:Connect(function()
        		textBox.BorderColor3 = Colors.Input.BorderFocus
        	end)

        	textBox.FocusLost:Connect(function()
        		textBox.BorderColor3 = Colors.Input.Border
        	end)

        	-- Return TextBox API
        	local textBoxAPI = {
        		GetText = function()
        			return currentText
        		end,
        		SetText = function(newText)
        			textBox.Text = tostring(newText or "")
        			currentText = textBox.Text
        			updateCharCounter()
        			-- Save to configuration
        			if flag then
        				-- Check if using custom config object
        				if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
        					EzUIConfig.SetValue(flag, currentText)
        				-- Fallback to EzUI.Flags
        				elseif EzUI and EzUI.Flags then
        					EzUI.Flags[flag] = currentText
        					-- Auto-save if enabled
        					if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
        						saveConfiguration(EzUI.Configuration.FileName)
        					end
        				end
        			end
        		end,
        		Clear = function()
        			textBox.Text = ""
        			currentText = ""
        			updateCharCounter()
        			-- Save to configuration
        			if flag then
        				-- Check if using custom config object
        				if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
        					EzUIConfig.SetValue(flag, currentText)
        				-- Fallback to EzUI.Flags
        				elseif EzUI and EzUI.Flags then
        					EzUI.Flags[flag] = currentText
        					-- Auto-save if enabled
        					if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
        						saveConfiguration(EzUI.Configuration.FileName)
        					end
        				end
        			end
        		end,
        		SetPlaceholder = function(newPlaceholder)
        			textBox.PlaceholderText = tostring(newPlaceholder or "")
        		end,
        		Focus = function()
        			textBox:CaptureFocus()
        		end,
        		Blur = function()
        			textBox:ReleaseFocus()
        		end,
        		SetCallback = function(newCallback)
        			callback = newCallback or function() end
        		end,
        		Set = function(newText)
        			textBox.Text = tostring(newText or "")
        			currentText = textBox.Text
        			updateCharCounter()
        		end
        	}

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, textBoxAPI)
        	end

        	return textBoxAPI
        end

        return TextBox

    end

    -- Module: components/accordion
    EmbeddedModules["components/accordion"] = function()
        --[[
        	Accordion Component
        	EzUI Library - Modular Component

        	Creates a collapsible accordion with dynamic content
        ]]

        -- Component modules (will be loaded by Window)
        local Accordion = {}

        local Colors
        local Button
        local Toggle
        local TextBox
        local NumberBox
        local SelectBox
        local Label
        local Separator

        -- Initialize component modules
        function Accordion:Init(_colors, _button, _toggle, _textbox, _numberbox, _selectbox, _label, _separator)
        	Colors = _colors
        	Button = _button
        	Toggle = _toggle
        	TextBox = _textbox
        	NumberBox = _numberbox
        	SelectBox = _selectbox
        	Label = _label
        	Separator = _separator
        end

        function Accordion:Create(config)
        	local title = config.Title or "Accordion"
        	local defaultExpanded = config.DefaultExpanded or false
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local onToggle = config.OnToggle or function() end

        	-- Accordion state
        	local isExpanded = defaultExpanded
        	local accordionHeight = 30
        	local contentHeight = 0
        	local components = {}

        	-- Main accordion container
        	local accordionContainer = Instance.new("Frame")
        	accordionContainer.Size = UDim2.new(1, -20, 0, accordionHeight)
        	accordionContainer.Position = UDim2.new(0, 10, 0, currentY)
        	accordionContainer.BackgroundColor3 = Colors.Background.Tertiary
        	accordionContainer.BorderSizePixel = 0
        	accordionContainer.ClipsDescendants = false
        	accordionContainer.ZIndex = 3
        	accordionContainer.Parent = parentContainer

        	-- Round corners
        	local containerCorner = Instance.new("UICorner")
        	containerCorner.CornerRadius = UDim.new(0, 4)
        	containerCorner.Parent = accordionContainer

        	-- Header (clickable)
        	local header = Instance.new("TextButton")
        	header.Size = UDim2.new(1, 0, 0, 30)
        	header.Position = UDim2.new(0, 0, 0, 0)
        	header.BackgroundColor3 = Colors.Surface.Default
        	header.BorderSizePixel = 0
        	header.Text = ""
        	header.ZIndex = 4
        	header.Parent = accordionContainer

        	-- Header round corners
        	local headerCorner = Instance.new("UICorner")
        	headerCorner.CornerRadius = UDim.new(0, 4)
        	headerCorner.Parent = header

        	-- Arrow indicator
        	local arrow = Instance.new("TextLabel")
        	arrow.Size = UDim2.new(0, 20, 1, 0)
        	arrow.Position = UDim2.new(0, 5, 0, 0)
        	arrow.BackgroundTransparency = 1
        	arrow.Text = isExpanded and "▼" or "►"
        	arrow.TextColor3 = Colors.Text.Secondary
        	arrow.TextSize = 12
        	arrow.Font = Enum.Font.SourceSansBold
        	arrow.ZIndex = 5
        	arrow.Parent = header

        	-- Title label
        	local titleLabel = Instance.new("TextLabel")
        	titleLabel.Size = UDim2.new(1, -30, 1, 0)
        	titleLabel.Position = UDim2.new(0, 25, 0, 0)
        	titleLabel.BackgroundTransparency = 1
        	titleLabel.Text = title
        	titleLabel.TextColor3 = Colors.Text.Primary
        	titleLabel.TextSize = 14
        	titleLabel.Font = Enum.Font.SourceSansBold
        	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        	titleLabel.ZIndex = 5
        	titleLabel.Parent = header

        	-- Content container with padding
        	local contentContainer = Instance.new("Frame")
        	contentContainer.Size = UDim2.new(1, -10, 1, -35)
        	contentContainer.Position = UDim2.new(0, 5, 0, 32)
        	contentContainer.BackgroundTransparency = 1
        	contentContainer.ClipsDescendants = false
        	contentContainer.Visible = isExpanded
        	contentContainer.ZIndex = 4
        	contentContainer.Parent = accordionContainer

        	-- Content scroll frame
        	local contentScrollFrame = Instance.new("ScrollingFrame")
        	contentScrollFrame.Size = UDim2.new(1, 0, 1, 0)
        	contentScrollFrame.Position = UDim2.new(0, 0, 0, 0)
        	contentScrollFrame.BackgroundTransparency = 1
        	contentScrollFrame.BorderSizePixel = 0
        	contentScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	contentScrollFrame.ScrollBarThickness = 6
        	contentScrollFrame.ScrollBarImageColor3 = Colors.Scrollbar.Thumb
        	contentScrollFrame.ClipsDescendants = false
        	contentScrollFrame.ZIndex = 4
        	contentScrollFrame.Parent = contentContainer

        	-- Function to update accordion size
        	local function updateSize()
        		local targetHeight = isExpanded and (contentHeight + 35) or 30

        		-- Animate size change
        		local tween = game:GetService("TweenService"):Create(
        			accordionContainer,
        			TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Size = UDim2.new(1, -20, 0, targetHeight)}
        		)
        		tween:Play()

        		-- Update canvas size
        		contentScrollFrame.CanvasSize = UDim2.new(0, 0, 0, contentHeight)
        	end

        	-- Function to animate content visibility
        	local function animateContent()
        		contentContainer.Visible = isExpanded

        		if isExpanded then
        			-- Fade in
        			for _, child in pairs(contentScrollFrame:GetChildren()) do
        				if child:IsA("GuiObject") then
        					child.Visible = true
        				end
        			end
        		end
        	end

        	-- Toggle function
        	local function toggle()
        		isExpanded = not isExpanded
        		arrow.Text = isExpanded and "▼" or "►"

        		animateContent()
        		updateSize()

        		-- Call callback
        		local success, err = pcall(function()
        			onToggle(isExpanded)
        		end)

        		if not success then
        			warn("Accordion toggle callback error:", err)
        		end
        	end

        	-- Header click handler
        	header.MouseButton1Click:Connect(toggle)

        	-- Hover effect
        	header.MouseEnter:Connect(function()
        		header.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	header.MouseLeave:Connect(function()
        		header.BackgroundColor3 = Colors.Surface.Default
        	end)

        	-- Initial state
        	if isExpanded then
        		animateContent()
        	end

        	-- Track current Y position for components inside accordion
        	local componentY = 0

        	-- Accordion API
        	local accordionAPI = {
        		Container = accordionContainer,
        		ContentFrame = contentScrollFrame,
        		IsExpanded = function()
        			return isExpanded
        		end,
        		Expand = function()
        			if not isExpanded then
        				toggle()
        			end
        		end,
        		Collapse = function()
        			if isExpanded then
        				toggle()
        			end
        		end,
        		Toggle = toggle,
        		SetTitle = function(newTitle)
        			title = newTitle
        			titleLabel.Text = newTitle
        		end,
        		GetContentHeight = function()
        			return contentHeight
        		end,
        		SetContentHeight = function(height)
        			contentHeight = height
        			updateSize()
        		end,
        		UpdateSize = updateSize,
        		AddComponent = function(component)
        			table.insert(components, component)
        		end,
        		GetComponents = function()
        			return components
        		end,

        		-- Add Button Component to Accordion
        		AddButton = function(buttonConfig)
        			if not Button then
        				warn("Accordion.AddButton: Button module not initialized")
        				return nil
        			end

        			local btnConfig = type(buttonConfig) == "string" and {Text = buttonConfig} or buttonConfig or {}
        			btnConfig.Parent = contentScrollFrame
        			btnConfig.Y = componentY
        			btnConfig.IsForAccordion = true
        			btnConfig.EzUI = config.EzUI
        			btnConfig.SaveConfiguration = config.SaveConfiguration
        			btnConfig.RegisterComponent = config.RegisterComponent

        			local buttonAPI = Button:Create(btnConfig)
        			componentY = componentY + 30
        			contentHeight = componentY
        			updateSize()

        			table.insert(components, buttonAPI)
        			return buttonAPI
        		end,

        		-- Add Toggle Component to Accordion
        		AddToggle = function(toggleConfig)
        			if not Toggle then
        				warn("Accordion.AddToggle: Toggle module not initialized")
        				return nil
        			end

        			toggleConfig = toggleConfig or {}
        			toggleConfig.Parent = contentScrollFrame
        			toggleConfig.Y = componentY
        			toggleConfig.IsForAccordion = true
        			toggleConfig.EzUI = config.EzUI
        			toggleConfig.SaveConfiguration = config.SaveConfiguration
        			toggleConfig.RegisterComponent = config.RegisterComponent
        			toggleConfig.EzUIConfig = config.EzUIConfig

        			local toggleAPI = Toggle:Create(toggleConfig)
        			componentY = componentY + 30
        			contentHeight = componentY
        			updateSize()

        			table.insert(components, toggleAPI)
        			return toggleAPI
        		end,

        		-- Add TextBox Component to Accordion
        		AddTextBox = function(textboxConfig)
        			if not TextBox then
        				warn("Accordion.AddTextBox: TextBox module not initialized")
        				return nil
        			end

        			textboxConfig = textboxConfig or {}
        			textboxConfig.Parent = contentScrollFrame
        			textboxConfig.Y = componentY
        			textboxConfig.IsForAccordion = true
        			textboxConfig.EzUI = config.EzUI
        			textboxConfig.SaveConfiguration = config.SaveConfiguration
        			textboxConfig.RegisterComponent = config.RegisterComponent
        			textboxConfig.EzUIConfig = config.EzUIConfig

        			local textboxAPI = TextBox:Create(textboxConfig)
        			componentY = componentY + 30
        			contentHeight = componentY
        			updateSize()

        			table.insert(components, textboxAPI)
        			return textboxAPI
        		end,

        		-- Add NumberBox Component to Accordion
        		AddNumberBox = function(numberboxConfig)
        			if not NumberBox then
        				warn("Accordion.AddNumberBox: NumberBox module not initialized")
        				return nil
        			end

        			numberboxConfig = numberboxConfig or {}
        			numberboxConfig.Parent = contentScrollFrame
        			numberboxConfig.Y = componentY
        			numberboxConfig.IsForAccordion = true
        			numberboxConfig.EzUI = config.EzUI
        			numberboxConfig.SaveConfiguration = config.SaveConfiguration
        			numberboxConfig.RegisterComponent = config.RegisterComponent
        			numberboxConfig.EzUIConfig = config.EzUIConfig

        			local numberboxAPI = NumberBox:Create(numberboxConfig)
        			componentY = componentY + 30
        			contentHeight = componentY
        			updateSize()

        			table.insert(components, numberboxAPI)
        			return numberboxAPI
        		end,

        		-- Add SelectBox Component to Accordion
        		AddSelectBox = function(selectboxConfig)
        			if not SelectBox then
        				warn("Accordion.AddSelectBox: SelectBox module not initialized")
        				return nil
        			end

        			selectboxConfig = selectboxConfig or {}
        			selectboxConfig.Parent = contentScrollFrame
        			selectboxConfig.Y = componentY
        			selectboxConfig.IsForAccordion = true
        			selectboxConfig.ScreenGui = config.ScreenGui
        			selectboxConfig.EzUI = config.EzUI
        			selectboxConfig.SaveConfiguration = config.SaveConfiguration
        			selectboxConfig.RegisterComponent = config.RegisterComponent
        			selectboxConfig.EzUIConfig = config.EzUIConfig

        			local selectboxAPI = SelectBox:Create(selectboxConfig)
        			componentY = componentY + 30
        			contentHeight = componentY
        			updateSize()

        			table.insert(components, selectboxAPI)
        			return selectboxAPI
        		end,

        		-- Add Label Component to Accordion
        		AddLabel = function(labelConfig)
        			if not Label then
        				warn("Accordion.AddLabel: Label module not initialized")
        				return nil
        			end

        			local lblConfig = type(labelConfig) == "string" and {Text = labelConfig} or labelConfig or {}
        			lblConfig.Parent = contentScrollFrame
        			lblConfig.Y = componentY
        			lblConfig.IsForAccordion = true

        			local labelAPI = Label:Create(lblConfig)
        			componentY = componentY + 25
        			contentHeight = componentY
        			updateSize()

        			table.insert(components, labelAPI)
        			return labelAPI
        		end,

        		-- Add Separator Component to Accordion
        		AddSeparator = function(separatorConfig)
        			if not Separator then
        				warn("Accordion.AddSeparator: Separator module not initialized")
        				return nil
        			end

        			separatorConfig = separatorConfig or {}
        			separatorConfig.Parent = contentScrollFrame
        			separatorConfig.Y = componentY
        			separatorConfig.IsForAccordion = true

        			local separatorAPI = Separator:Create(separatorConfig)
        			componentY = componentY + 15
        			contentHeight = componentY
        			updateSize()

        			table.insert(components, separatorAPI)
        			return separatorAPI
        		end
        	}

        	return accordionAPI
        end

        return Accordion

    end

    -- Load module helper function
    local function loadModule(url)
        -- Try embedded module first
        if EmbeddedModules[url] then
            return EmbeddedModules[url]()
        end

        -- Fallback to original require
        return require(url)
    end

    -- Main Script
    --[[
    	EzUI - Easy Roblox UI Library
    	Main Entry Point

    	A modern, modular UI library for Roblox with:
    	- Centralized color palette system
    	- Configuration management with auto-save/load
    	- 10+ UI components
    	- Tab system with icons
    	- Window management with drag & resize

    	Usage:
    		local EzUI = require(game.ReplicatedStorage.main)

    		local window = EzUI.({
    			Name = "My UI",
    			Size = {Width = 500, Height = 400}
    		})

    		local tab = window:AddTab("Home")
    		tab:AddButton("Click Me", function()
    			print("Button clicked!")
    		end)
    ]]

    local EzUI = {}

    -- Import utility modules
    local ColorsModule = loadModule("utils/colors")
    local ConfigModule = loadModule("utils/config")

    -- Debug: Verify Colors loaded
    if ColorsModule then
    	print("✅ Colors module loaded successfully")
    	if ColorsModule.Background then
    		print("✅ Colors.Background exists")
    	else
    		warn("❌ Colors.Background is nil!")
    	end
    else
    	warn("❌ Colors module is nil!")
    end

    -- Import components
    local Accordion = loadModule("components/accordion")
    local Button = loadModule("components/button")
    local Label = loadModule("components/label")
    local NumberBox = loadModule("components/numberbox")
    local SelectBox = loadModule("components/selectbox")
    local Separator = loadModule("components/separator")
    local Tab = loadModule("components/tab")
    local TextBox = loadModule("components/textbox")
    local Toggle = loadModule("components/toggle")
    local Window = loadModule("components/window")

    -- Custom Configuration System
    function EzUI:NewConfig(config)
    	return ConfigModule:NewConfig(config)
    end

    -- Initialize Components
    print("🔧 Initializing components...")
    Accordion:Init(ColorsModule, Button, Toggle, TextBox, NumberBox, SelectBox, Label, Separator)
    Button:Init(ColorsModule)
    Label:Init(ColorsModule)
    NumberBox:Init(ColorsModule)
    SelectBox:Init(ColorsModule)
    Separator:Init(ColorsModule)
    Tab:Init(ColorsModule, Accordion, Button, Toggle, TextBox, NumberBox, SelectBox, Label, Separator)
    TextBox:Init(ColorsModule)
    Toggle:Init(ColorsModule)
    Window:Init(ColorsModule, Accordion, Button, Label, NumberBox, SelectBox, Separator, Tab, TextBox, Toggle)
    print("✅ All components initialized")

    -- Main Window Creation Function
    function EzUI:CreateWindow(config)
    	print("🪟 Creating window...")

    	-- Pass all required modules and config to Window component
    	local windowSetup = {
    		Title = config.Title or config.Name or "EzUI Window",
    		Width = config.Width or (config.Size and config.Size.Width) or 600,
    		Height = config.Height or (config.Size and config.Size.Height) or 400,
    		Opacity = config.Opacity or 0.9,
    		AutoShow = config.AutoShow or true,
    		Draggable = config.Draggable,
    		BackgroundColor = config.BackgroundColor,
    		CornerRadius = config.CornerRadius,
    	}

    	-- Create config system
    	local configSystem = ConfigModule:NewConfig({
    		FolderName = config.FolderName or "EzUI",
    		FileName = config.FileName or "Settings",
    	})

    	-- Store config in EzUI for global access
    	EzUI.Config = configSystem

    	return Window:Create(windowSetup)
    end

    -- Expose version info
    EzUI.Version = "2.0.0"
    EzUI.Author = "EzUI Library"

    return EzUI
end

-- Load module helper function
local function loadModule(url)
    -- Try embedded module first
    if EmbeddedModules[url] then
        return EmbeddedModules[url]()
    end
    
    -- Fallback to original require
    return require(url)
end

-- Main Script
local EzUI = loadModule("../output/bundle.lua")

local window = EzUI:CreateWindow({
    Name = "My First Window",
    Size = { Width = 800, Height = 600 },
    Opacity = 0.95,
    AutoShow = true,
})